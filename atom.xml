<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://halftop.github.io</id>
    <title>1/2顶点</title>
    <updated>2019-05-27T13:25:10.306Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://halftop.github.io"/>
    <link rel="self" href="https://halftop.github.io/atom.xml"/>
    <subtitle>    有输入有输出，才是正确的学习方式    </subtitle>
    <logo>https://halftop.github.io/images/avatar.png</logo>
    <icon>https://halftop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 1/2顶点</rights>
    <entry>
        <title type="html"><![CDATA[Verilog99题-57题]]></title>
        <id>https://halftop.github.io/post/verilog99-57</id>
        <link href="https://halftop.github.io/post/verilog99-57">
        </link>
        <updated>2019-05-27T09:23:20.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>在clk a时钟域的一个单周期脉冲信号，如何正确的传递到clk b时钟域? 要考虑clk a和b的各种不同频率/相位的场景。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>在clk a时钟域的一个单周期脉冲信号，如何正确的传递到clk b时钟域? 要考虑clk a和b的各种不同频率/相位的场景。</p>
</blockquote>
<!-- more --> 
<h2 id="总结">总结</h2>
<p>关于单bit信号的跨时钟域传输<a href="https://www.cnblogs.com/IClearner/p/6485389.html">这篇博客</a>总结的比较详细，这里直接copy一下结论：</p>
<blockquote>
<ul>
<li>在跨时钟域的时候，不一定需要跨时钟域电路（同步器或者握手信号），接近异步时钟或者就是异步时钟的时候跨时钟域就得加上了。</li>
<li>在慢到快的时钟域中，加上触发器链（两级触发器）基本上就可以了，主要是抑制亚稳态的传播。</li>
<li>但是在快到慢的时钟域中，不仅需要触发器链进行抑制亚稳态的传播，还要防止慢时钟域采不到快时钟域的数据，因此就添加反馈/握手电路（这个反馈信号是指跨时钟域的反馈信号）。（可以使用脉冲展宽）</li>
</ul>
</blockquote>
<h2 id="verilog描述">Verilog描述</h2>
<p>参考了<a href="https://wx.zsxq.com/dweb/#/index/458811454428"><strong>NingHeChua*</strong></a>的描述</p>
<h3 id="慢时钟域到快时钟域两级寄存器同步">慢时钟域到快时钟域，两级寄存器同步</h3>
<pre><code class="language-verilog">module Sync_Pulse(
        input           clkb,
        input           rst_n,
        input           pulse_ina,
        output          pulse_outb
    );
    
    reg	signal_r;
    reg signal_rr;
    
    always @ (posedge clkb or negedge rst_n)
        if (!rst_n) begin
           signal_r &lt;= 1'b0;
           signal_rr &lt;= 1'b0;
        end else begin
           signal_r &lt;= pulse_ina;
           signal_rr &lt;= signal_r;
        end
    assign pulse_outb = signal_rr;
endmodule
</code></pre>
<h3 id="快时钟域到慢时钟域">快时钟域到慢时钟域</h3>
<pre><code class="language-verilog">module Sync_Pulse(
    input           clka,
    input           clkb,
    input           rst_n,
    input           pulse_ina,
    output          pulse_outb,
    output          signal_outb
);
//-------------------------------------------------------
reg             signal_a;
reg             signal_b;
reg             signal_b_r;
reg             signal_b_rr;
reg             signal_a_r;
reg             signal_a_rr;
//-------------------------------------------------------
//在clka下，生成展宽信号signal_a
always @(posedge clka or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_a &lt;= 1'b0;
    end
    else if(pulse_ina == 1'b1)begin
        signal_a &lt;= 1'b1;
    end
    else if(signal_a_rr == 1'b1)
        signal_a &lt;= 1'b0;
    else 
        signal_a &lt;= signal_a;
end
//-------------------------------------------------------
//在clkb下同步signal_a
always @(posedge clkb or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_b &lt;= 1'b0;
    end
    else begin
        signal_b &lt;= signal_a;
    end
end
//-------------------------------------------------------
//在clkb下生成脉冲信号和输出信号
always @(posedge clkb or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_b_r &lt;= 'b0;
        signal_b_rr &lt;= 'b0;
    end
    else begin
        signal_b_rr &lt;= signal_b_r;
        signal_b_r &lt;= signal_b;
    end
end
assign    pulse_outb = ~signal_b_rr &amp; signal_b_r;
assign    signal_outb = signal_b_rr;
//-------------------------------------------------------
//在clka下采集signal_b_rr，生成signal_a_rr用于反馈拉低signal_a
always @(posedge clka or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_a_r &lt;= 'b0;
        signal_a_rr &lt;= 'b0;
    end
    else begin
        signal_a_rr &lt;= signal_a_r;
        signal_a_r &lt;= signal_b_rr;
    end
end
endmodule
</code></pre>
<center>
 <img src="https://i.loli.net/2019/05/27/5cebb39c27a3271351.png" alt="rtl图" title="rtl图" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AMBA-APB总线协议学习]]></title>
        <id>https://halftop.github.io/post/amba-apb</id>
        <link href="https://halftop.github.io/post/amba-apb">
        </link>
        <updated>2019-05-22T11:58:34.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>The Advanced Peripheral Bus(APB)is part of the Advanced Microcontroller Bus architecture (AMBA)protocol family. It defines a low-cost interface that is optimized for minimal consumption and reduced interface complexity.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>The Advanced Peripheral Bus(APB)is part of the Advanced Microcontroller Bus architecture (AMBA)protocol family. It defines a low-cost interface that is optimized for minimal consumption and reduced interface complexity.</p>
</blockquote>
<!-- more -->
<blockquote>
<p>The APB protocol is not pipelined, use it to connect to low-bandwidth peripherals that do not require the high performance of the AXI protocol.</p>
<p>The APB protocol relates a signal transition to the rising edge of the clock, to simplify the integration of APB peripherals into any design flow. Every transfer takes at least two cycles.</p>
<p>The APB can interface with :</p>
<ul>
<li>
<p>AMBA Advanced High-performance Bus (AHB)</p>
</li>
<li>
<p>AMBA Advanced High-performance Bus Lite (AHB-Lite)</p>
</li>
<li>
<p>AMBA Advanced Extensible Interface (AXI)</p>
</li>
<li>
<p>AMBA Advanced Extensible Interface Lite (ax4-Lite)</p>
</li>
</ul>
<p>You can use it to access the programmable control registers of peripheral devices.</p>
</blockquote>
<h2 id="版本">版本</h2>
<ol>
<li>The APB Specification Rev E, released in 1998（过时）</li>
<li>AMBA 2 APB Specification</li>
<li>AMBA 3 APB Protocol Specification v1.0</li>
<li>AMBA APB Protocol Specification v2.0.</li>
</ol>
<h2 id="信号">信号</h2>
<p>英语通俗易懂。</p>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce549f1335d014773.png" alt="APB signal descriptions" title="APB signal descriptions" width="900"> 
</center>
<p>简要翻译一下，建议看上方英文原版。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>来源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCLK</td>
<td>时钟源</td>
<td>系统时钟，传输发生在上升沿</td>
</tr>
<tr>
<td>PRESETn</td>
<td>复位源</td>
<td>复位信号，低使能</td>
</tr>
<tr>
<td>PADDR</td>
<td>APB桥</td>
<td>地址信号，最高可达32位</td>
</tr>
<tr>
<td>PPROT</td>
<td>APB桥</td>
<td>保护类型，详见手册</td>
</tr>
<tr>
<td>PSELx</td>
<td>APB桥</td>
<td>片选信号，表示x从机是否被选中</td>
</tr>
<tr>
<td>PENABLE</td>
<td>APB桥</td>
<td>使能信号，标记传输使能</td>
</tr>
<tr>
<td>PWRITE</td>
<td>APB桥</td>
<td>读/写控制信号，高位写，低为读</td>
</tr>
<tr>
<td>PWDATA</td>
<td>APB桥</td>
<td>写数据</td>
</tr>
<tr>
<td>PSTRB</td>
<td>APB桥</td>
<td>写选通信号，指示哪个字节是有效的数据，详见手册。</td>
</tr>
<tr>
<td>PREADY</td>
<td>从机</td>
<td>标记从机是否已将数据发送到总线，高为ready</td>
</tr>
<tr>
<td>PRDATA</td>
<td>从机</td>
<td>读数据</td>
</tr>
<tr>
<td>PSLVERR</td>
<td>从机</td>
<td>故障信号，高为发生故障</td>
</tr>
</tbody>
</table>
<h2 id="写时序">写时序</h2>
<h3 id="无等待模式">无等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce54bee66ef089847.png" alt="Write transfer with no wait states" title="Write transfer with no wait states" width=""> 
</center>
<p>两个阶段：<strong>the Setup phase</strong>（设置阶段？），<strong>the Access phase</strong>（访问阶段？）</p>
<p><strong>the Setup phase</strong>（设置阶段）：在T1，地址<strong>PADDR</strong>，写入数据<strong>PWDATA</strong>，写入信号<strong>PWRITE</strong>和选择信号<strong>PSEL</strong>在<strong>PCLK</strong>的上升沿进行寄存，这标志着写操作的开始。</p>
<p><strong>the Access phase</strong>（访问阶段）：在T2，使能信号<strong>PENABLE</strong>和就绪信号<strong>PREADY</strong>在PCLK的上升沿被寄存。</p>
<p><strong>PENABLE</strong>变高表示访问阶段的开始；<strong>PREADY</strong>变高表示从机可以在PCLK的下一个上升沿完成传输。</p>
<p>地址<strong>PADDR</strong>，写入数据<strong>PWDATA</strong>和控制信号都要在传输在T3（<strong>the Access phase</strong>结束）之前保持有效。</p>
<p>使能信号<strong>PENABLE</strong>在传输结束时被置为低电平。选择信号<strong>PSEL</strong>也被置为低电平，除非其后紧跟着对同一外设的另一次写操作。</p>
<h3 id="等待模式">等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce5527ea63b932405.png" alt="Write transfer with wait states" title="Write transfer with wait states" width=""> 
</center>
<p>等待模式引入从机状态信号<strong>PREADY</strong>。在访问阶段，当<strong>PENABLE</strong>为高电平时，从机通过拉低<strong>PREADY</strong>来延时写操作。<strong>PREADY</strong>为低电平期间，以下信号保持不变：</p>
<ul>
<li>address, <strong>PADDR</strong></li>
<li>write signal, <strong>PWRITE</strong></li>
<li>select signal, <strong>PSEL</strong></li>
<li>enable signal, <strong>PENABLE</strong></li>
<li>write data, <strong>PWDATA</strong></li>
<li>write strobes, <strong>PSTRB</strong></li>
<li>protection type, <strong>PPROT</strong>.</li>
</ul>
<p>当<strong>PENABLE</strong>为低电平时，<strong>PREADY</strong>可以设置为任何值以确保具有固定双周期访问权限的外设可以将<strong>PREADY</strong>置为高电平。</p>
<p><strong>注意</strong>：推荐直到下一次访问开始，地址和写操作相关信号一直保持不变。这样可以降低功耗。</p>
<h2 id="读时序">读时序</h2>
<h3 id="无等待模式-2">无等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce557c70f34888108.png" alt=" Read transfer with no wait states" title=" Read transfer with no wait states" width=""> 
</center>
<p>对照无等待写时序理解，从器件必须在读传输结束前提供数据。</p>
<h3 id="等待模式-2">等待模式</h3>
<p>如果在访问阶段<strong>PREADY</strong>被从机置为低电平，则传输会延时。<strong>PREADY</strong>为低电平期间，以下信号保持不变：</p>
<ul>
<li>address, <strong>PADDR</strong></li>
<li>write signal, <strong>PWRITE</strong></li>
<li>select signal, <strong>PSEL</strong></li>
<li>enable signal, <strong>PENABLE</strong></li>
<li>protection type, <strong>PPROT</strong>.</li>
</ul>
<p>下图显示延时两个时钟周期：</p>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce559ddb398d66056.png" alt="Read transfer with wait states" title="Read transfer with wait states" width=""> 
</center>
<h2 id="系统状态转移">系统状态转移</h2>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce55cbd1326789441.png" alt="State diagram" title="State diagram" width=""> 
</center>
<ul>
<li>
<p>IDLE：初始状态，也是等待传输状态。当片选信号PSELx拉高时总线请求通信，进入SETUP状态</p>
</li>
<li>
<p>SETUP：设置阶段，主从机在该状态设置相应的信号，准备好所有数据。只在该状态停留一个周期，总是在时钟的下一个上升沿到来时进入ACCESS阶段。</p>
</li>
<li>
<p>ACCESS：访问阶段，拉高<strong>PENABLE</strong>信号。在从SETUP到ACCESS状态的转换期间，地址，写入，选择和写入数据信号必须保持稳定。</p>
<p>退出ACCESS阶段由从机状态信号<strong>PREADY</strong>控制：</p>
<ul>
<li>当<strong>PREADY</strong>信号拉高，传输完成，根据是否有下一次传输（<strong>PSELx</strong>是否为高），进入IDLE状还是SETUP状态。</li>
<li>当<strong>PREADY</strong>信号为低，数据未准备好，在ACCESS状态等待<strong>PREADY</strong>信号拉高。</li>
</ul>
</li>
</ul>
<h2 id="其它功能日后补充">其它功能（日后补充）</h2>
<h3 id="写选通">写选通</h3>
<h3 id="传输错误响应">传输错误响应</h3>
<h3 id="保护单元支持">保护单元支持</h3>
<p>参考文档：<a href="https://static.docs.arm.com/ihi0024/c/IHI0024C_amba_apb_protocol_spec.pdf">AMBA APB Protocol Specification v2.0</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-50-52题]]></title>
        <id>https://halftop.github.io/post/verilog99-50to52</id>
        <link href="https://halftop.github.io/post/verilog99-50to52">
        </link>
        <updated>2019-05-20T02:02:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的50-52题是关于亚稳态和复位亚稳态消除问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的50-52题是关于亚稳态和复位亚稳态消除问题。</p>
<!-- more -->
<h3 id="50解释一下亚稳态">50.解释一下亚稳态。</h3>
<p>触发器的建立时间和保持时间在时钟上升沿左右定义了一个时间窗口，如果触发器数据输入端口上的数据在这个时间窗口内发生变化（或者数据更新），那么就会产生时序违规。如果数据在上述窗口中被采集，触发器中的晶体管不能可靠地设置为逻辑0或者逻辑1对应的电平上，导致触发器的输出无法在某个规定时间段内达到一个可以确定的状态，介于0和1之间。亚稳态是可以传播的。</p>
<h3 id="51-用verilog实现异步复位同步释放电路">51. 用verilog实现异步复位同步释放电路。</h3>
<p>关于异步复位，同步释放的更多内容：<a href="https://www.cnblogs.com/linjie-swust/archive/2012/01/07/YWT.html">FPGA中亚稳态——让你无处可逃</a></p>
<center>
 <img src="https://i.loli.net/2019/05/20/5ce2156dd372699513.jpg" alt="异步复位，同步释放" title="异步复位，同步释放" width="600"> 
</center>
<pre><code class="language-verilog">module reset_gen (
    input					clk			, 
    input					rst_async_n	,
    output					rst_sync_n	
);
reg rst_s1, rst_s2;

always @ (posedge clk or negedge rst_async_n)
    if (!rst_async_n)
         begin 
            rst_s1 &lt;= 1'b0;
            rst_s2 &lt;= 1'b0;
        end
    else 
        begin
            rst_s1 &lt;= 1'b1;
            rst_s2 &lt;= rst_s1;
        end

assign rst_sync_n = rst_s2; //rst_sync_n才是我们真正对系统输出的复位信号

endmodule 
</code></pre>
<h3 id="52-用verilog实现异步复位同步释放电路支持测试模式的复位信号切换">52. 用verilog实现异步复位同步释放电路，支持测试模式的复位信号切换。</h3>
<pre><code class="language-verilog">module reset_gen (
    input					clk			, 
    input					rst_async_n	,
    input					test_shift  ,
    output					rst_sync_n	
);
reg rst_s1;
reg rst_s2;
wire tmrst;

assign  tmrst = rst_async_n | test_shift;

always @ (posedge clk or negedge tmrst)
    if (!tmrst)
         begin 
            rst_s1 &lt;= 1'b0;
            rst_s2 &lt;= 1'b0;
        end
    else 
        begin
            rst_s1 &lt;= 1'b1;
            rst_s2 &lt;= rst_s1;
        end

assign rst_sync_n = rst_s2;

endmodule 
</code></pre>
<p>这个测试模式的用意还未领悟，本题的<a href="https://www.eetimes.com/document.asp?doc_id=1145510">参考链接</a>。以门控时钟和复位信号，讲解了测试模式的一些知识。文章中有一处错误，讲解复位信号的测试模式切换的时候，少写了取反符号（粗心所致）。如下图：</p>
<center>
 <img src="https://i.loli.net/2019/05/20/5ce265a70875a57159.png" alt="错误示例" title="错误示例" width=""> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog没有葵花宝典——day13（存储器）]]></title>
        <id>https://halftop.github.io/post/verilog-day13</id>
        <link href="https://halftop.github.io/post/verilog-day13">
        </link>
        <updated>2019-05-16T08:24:29.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>存储名词解释</li>
<li>用verilog实现一个深度为16，位宽8bit的单端口SRAM。搭建一个仿真环境，完成初始化，读取，写入的操作。</li>
<li>接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</li>
<li>使用单端口SRAM构造一个双端口同步FIFO。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>存储名词解释</li>
<li>用verilog实现一个深度为16，位宽8bit的单端口SRAM。搭建一个仿真环境，完成初始化，读取，写入的操作。</li>
<li>接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</li>
<li>使用单端口SRAM构造一个双端口同步FIFO。</li>
</ol>
</blockquote>
<!-- more --> 
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#1-%E5%AD%98%E5%82%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">1. 存储名词解释</a></li>
<li><a href="#2-%E5%8D%95%E7%AB%AF%E5%8F%A3sram">2. 单端口SRAM</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">Verilog描述</a></li>
<li><a href="#testbench">testbench</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%A5%E7%AC%AC2%E9%A2%98%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%92%8C%E5%86%99%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%80%8E%E6%A0%B7%E5%AE%9E%E9%99%85%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">3. 接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8%E5%8D%95%E7%AB%AF%E5%8F%A3sram%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%90%8C%E6%AD%A5fifo">4. 使用单端口SRAM构造一个双端口同步FIFO。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="1-存储名词解释">1. 存储名词解释</h3>
<p>见<a href="https://halftop.github.io/post/verilog99_31to37/#31%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">Verilog99题的第31题</a></p>
<h3 id="2-单端口sram">2. 单端口SRAM</h3>
<h4 id="verilog描述">Verilog描述</h4>
<pre><code class="language-verilog">module spram
#(
    parameter WD = 8,       //数据位宽
    parameter AD = 4       //地址位宽
)
(
    input               clk     ,
    input               cs_n    ,
    input               w_r_n   ,
    input       [AD-1:0]  addr    ,
    input       [WD-1:0]  din     ,
    output  reg [WD-1:0]  dout    
    );
localparam	DP=1&lt;&lt;AD；
reg [WD-1:0]  buffer  [DP-1:0];

always @(posedge clk) begin
    casex ({cs_n,w_r_n})
        2'b1x: dout &lt;= 'hx;
        2'b01: buffer[addr] &lt;= din;
        2'b00: dout &lt;= buffer[addr];
        default: ;
    endcase
end

endmodule
</code></pre>
<h4 id="testbench">testbench</h4>
<pre><code class="language-verilog">`timescale 1ns / 1ps

// memory inst hierachy name
`define MEM_INST      tb34.spram16_8.buffer
// memory initilazation file (hex format)
`define MEM_INIT_FILE &quot;E:/verilog/test/test.srcs/sources_1/new/sp_mem_init.hex&quot;

module tb34(    );
reg             clk     ;
reg             cs_n    ;
reg             w_r_n   ;
reg     [4:1]   addr    ;
reg     [8:1]   din     ;
wire    [8:1]   dout    ;

initial begin
    clk = 1;
    forever #10 clk = ~clk;
  end

// memory initilization
integer fp_dmem;

initial begin
    fp_dmem = $fopen(`MEM_INIT_FILE, &quot;r&quot;);  //open for read
    if(fp_dmem)
        #5 $readmemh(`MEM_INIT_FILE, `MEM_INST);
    else begin
        $display(&quot;%s open failed.&quot;,`MEM_INIT_FILE);
        $finish;
    end
end

integer i;
initial begin
    cs_n = 1'b1;
    w_r_n = 1'b0;
    addr = 4'd0;
    din = 8'h00;
    #100
    @(negedge clk)//read
        cs_n = 1'b0;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk)
            addr = i;
    end
    @(negedge clk)//write
        w_r_n = 1'b1;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk) begin
            addr = i;
            din = i + 'ha0;
        end
    end
    @(negedge clk)//read
        w_r_n = 1'b0;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk)
            addr = i;
    end
    @(negedge clk)
        cs_n = 1'b1;
    // #100 $finish;
    #100 $stop;
end

/* initial begin
    $dumpfile(&quot;spram_tb.vcd&quot;);
    $dumpvars();
end */
spram #(
    .WD ( 8),
    .AD ( 4)
)
spram16_8
(
    .clk     ( clk   ),
    .cs_n    ( cs_n  ),
    .w_r_n   ( w_r_n ),
    .addr    ( addr  ),
    .din     ( din   ),
    .dout    ( dout  )
    );
endmodule
</code></pre>
<h3 id="3-接第2题如果同时对一个地址进行读和写操作会怎样实际中应该如何处理">3. 接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</h3>
<p>目前的水平觉得不会，但是大神们讨论了很多，不敢说话。</p>
<h3 id="4-使用单端口sram构造一个双端口同步fifo">4. 使用单端口SRAM构造一个双端口同步FIFO。</h3>
<p>放出大神的思路<a href="https://mp.weixin.qq.com/s/Sl9-BeUJ6bUNzjsUQvYqUQ">使用单端口SRAM构造一个双端口同步FIFO</a></p>
<p>只想说厉害了！说得比较通俗易懂，实现起来没那么简单~</p>
<p>估计今天是实现不了了，留坑！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-47-49题（时钟相关）]]></title>
        <id>https://halftop.github.io/post/verilog99-47to49</id>
        <link href="https://halftop.github.io/post/verilog99-47to49">
        </link>
        <updated>2019-05-14T08:32:38.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的47-49题是关于时钟。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的47-49题是关于时钟。</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#47-%E7%94%BB%E5%87%BAclock-gating-cell%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE">47. 画出clock gating cell的原理图。</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8Elatch%E5%92%8C%E4%B8%8E%E9%97%A8">基于latch和与门</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Elatch%E5%92%8C%E6%88%96%E9%97%A8">基于latch和或门</a></li>
<li><a href="#48-%E7%94%A8verilog%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E7%94%B5%E8%B7%AF-%E5%A4%96%E9%83%A8%E7%AE%A1%E8%84%9A%E8%BE%93%E5%85%A5selclktestclk-sel%E4%B8%BA1%E8%BE%93%E5%87%BAclksel%E4%B8%BA0%E8%BE%93%E5%87%BAtestclk">48. 用verilog实现静态时钟切换电路。外部管脚输入sel，clk，testclk。sel为1输出clk，sel为0输出testclk。</a></li>
<li><a href="#49-%E7%94%A8verilog%E5%AE%9E%E7%8E%B0glitch-free%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E7%94%B5%E8%B7%AF-%E8%BE%93%E5%85%A5selclkaclkbsel%E4%B8%BA1%E8%BE%93%E5%87%BAclkasel%E4%B8%BA0%E8%BE%93%E5%87%BAclkb">49. 用verilog实现glitch free时钟切换电路。输入sel，clka，clkb，sel为1输出clka，sel为0输出clkb。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="47-画出clock-gating-cell的原理图">47. 画出clock gating cell的原理图。</h3>
<h4 id="基于latch和与门">基于latch和与门</h4>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda80576019768349.png" alt="ICG_AND" title="ICG_AND" width=""> 
</center>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda83e3d3c2768584.png" alt="AND_ICG_tim" title="AND_ICG_tim" width=""> 
</center>
<h4 id="基于latch和或门">基于latch和或门</h4>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda80ab9f0fa61819.png" alt="ICG_OR" title="ICG_OR" width=""> 
</center>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda84254038421193.png" alt="OR_ICG_timOR_ICG_tim" title="OR_ICG_tim" width=""> 
</center>
<h4 id="48-用verilog实现静态时钟切换电路-外部管脚输入selclktestclk-sel为1输出clksel为0输出testclk">48. 用verilog实现静态时钟切换电路。外部管脚输入sel，clk，testclk。sel为1输出clk，sel为0输出testclk。</h4>
<pre><code class="language-verilog">module clk_switch(
    input                   clk0        ,
    input                   clk1        ,
    input                   rst_n       ,
    input                   select      ,
    output                  outclk      
    );

    assign outclk = select ? clk1 : clk0;
</code></pre>
<h4 id="49-用verilog实现glitch-free时钟切换电路-输入selclkaclkbsel为1输出clkasel为0输出clkb">49. 用verilog实现glitch free时钟切换电路。输入sel，clka，clkb，sel为1输出clka，sel为0输出clkb。</h4>
<pre><code class="language-verilog">module clk_switch(
    input                   clk0        ,
    input                   clk1        ,
    input                   rst_n       ,
    input                   select      ,
    output                  outclk      
    );

reg     out_r1;
reg     out1;
reg     out_r0;
reg     out0;
 
 always @(posedge clk1 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out_r1 &lt;= 0;
     end
     else begin
         out_r1 &lt;= ~out0 &amp; select;
     end
 end
 
 always @(negedge clk1 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out1 &lt;= 0;
     end
     else begin
         out1 &lt;= out_r1;
     end
 end
 
 always @(posedge clk0 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out_r0 &lt;= 0;
     end
     else begin
         out_r0 &lt;= ~select &amp; ~out1;
     end
 end
 
 always @(negedge clk0 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out0 &lt;= 0;
     end
     else begin
         out0 &lt;= out_r0;
     end
 end
 
 assign outclk = (out1 &amp; clk1) | (out0 &amp; clk0);
endmodule
</code></pre>
<p>具体请点击<a href="https://mp.weixin.qq.com/s/w3Wu7HkSr5v94kHrLvRIcw">中文版</a>或<a href="https://www.eetimes.com/document.asp?doc_id=1202359">英文版</a>。</p>
<p><a href="https://www.cnblogs.com/-9-8/p/5409862.html">另附1篇</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题——45.46题（奇、偶分频）]]></title>
        <id>https://halftop.github.io/post/verilog99-45to46</id>
        <link href="https://halftop.github.io/post/verilog99-45to46">
        </link>
        <updated>2019-05-10T07:58:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="45">
<li>用verilog实现二分频。</li>
<li>用verilog实现三分频电路，要求输出50%占空比。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="45">
<li>用verilog实现二分频。</li>
<li>用verilog实现三分频电路，要求输出50%占空比。</li>
</ol>
</blockquote>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E6%96%B9%E6%B3%95">思路及方法</a></li>
<li><a href="#45">45</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">verilog描述</a></li>
</ul>
</li>
<li><a href="#46">46</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-2">verilog描述</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">仿真结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="思路及方法">思路及方法</h3>
<p>偶数分频十分简单,只需用高速时钟做一个同步计数器,然后在相应的位抽头即可。奇数分频电路相对复杂些。引用一篇比较详细的blog：<a href="https://mp.weixin.qq.com/s/Xd6vn51L1hD0mRClQbVfaQ">verilog实现简单分频器</a></p>
<h3 id="45">45</h3>
<h4 id="verilog描述">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: 二分频
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-10 10:37:19
// LastEditTime: 2019-05-10 11:04:06
// ********************************************************************
// Module Function:二分频
`timescale 1ns / 1ps

module div_2(
    input					clk			,
    input					rst_n		,
    output  reg             clk_out     
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out &lt;= 1'b0;
    end else begin
        clk_out &lt;= ~clk_out;
    end
end

endmodule
</code></pre>
<h3 id="46">46</h3>
<h4 id="verilog描述-2">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: 实现任意奇数分频
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-10 11:04:51
// LastEditTime: 2019-05-10 22:18:17
// ********************************************************************
// Module Function:实现任意奇数分频
`timescale 1ns / 1ps

module div_odd
#(
    parameter N	= 3
    
)
(
    input					clk			,
    input					rst_n		,
    output                  clk_out     
);

localparam  WD = clogb2(N);

reg                 clk_out_p   ;
reg                 clk_out_n   ;
reg     [WD-1:0]    count       ;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        count &lt;= 'd0;
    end else if (count==N-1) begin
        count &lt;= 'd0;
    end else begin
        count &lt;= count + 1'b1;
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out_p &lt;= 1'b1;
    end else if (count&gt;N/2) begin
        clk_out_p &lt;= 1'b0;
    end else begin
        clk_out_p &lt;= 1'b1;
    end
end

always @(negedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out_n &lt;= 1'b0;
    end else begin
        clk_out_n &lt;= clk_out_p;
    end
end

assign clk_out = clk_out_p&amp;clk_out_n;

function integer clogb2 (input integer depth);
    begin
        for(clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
    end
endfunction

endmodule
</code></pre>
<h4 id="仿真结果">仿真结果</h4>
<p>三分频：</p>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd589db5ed2a.png" alt="三分频仿真结果" title="三分频仿真结果" width="800"> 
</center>
<p>七分频：</p>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd58b4047f97.png" alt="七分频仿真结果" title="七分频仿真结果" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题——43、44题（两道算法题）]]></title>
        <id>https://halftop.github.io/post/verilog99_43to44</id>
        <link href="https://halftop.github.io/post/verilog99_43to44">
        </link>
        <updated>2019-05-10T07:56:46.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="43">
<li>用verilog实现 <code>y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)</code> 输入x是8bit无符号数。</li>
<li>用verilog实现 <code>y(n) = 0.75*x(n) + 0.25*y(n-1)</code> x, y是8bit无符号数。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="43">
<li>用verilog实现 <code>y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)</code> 输入x是8bit无符号数。</li>
<li>用verilog实现 <code>y(n) = 0.75*x(n) + 0.25*y(n-1)</code> x, y是8bit无符号数。</li>
</ol>
</blockquote>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#43">43</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">verilog描述</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E5%9B%BE">仿真图</a></li>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-2">verilog描述</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E5%87%BA%E7%9A%84%E7%94%B5%E8%B7%AF%E5%9B%BE">综合出的电路图</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">仿真结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="43">43</h3>
<p>用移位寄存器实现时延，这里参数化了位宽和个数，注意组合逻辑中阻塞赋值的用法。</p>
<h4 id="verilog描述">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)+···
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-09 10:30:00
// LastEditTime: 2019-05-09 15:58:20
// ********************************************************************
// Module Function:
`timescale 1ns / 1ps

module test43
#(
    parameter WIDTH	= 8 ,
                DEPTH = 8   ,
                YWD = WIDTH+clogb2(DEPTH)
)
(
    input					clk			,
    input					rst_n		,
    input       [WIDTH-1:0] i_data      ,
    output  reg [YWD-1:0]   o_y 
);

reg     [WIDTH-1:0]     data_r      [DEPTH-1:0];

integer i;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for ( i=0 ;i&lt;DEPTH ;i=i+1 ) begin
            data_r[i] &lt;= 'd0;
        end
    end else begin
        data_r[0] &lt;= i_data;
        for ( i=1 ;i&lt;DEPTH ;i=i+1 ) begin
            data_r[i] &lt;= data_r[i-1];
        end
    end
end

reg     [YWD-1:0] sum_comb;
always @(*) begin
    sum_comb = 'd0;
    for ( i=0 ;i&lt;DEPTH ; i=i+1) begin
        sum_comb = sum_comb + data_r[i];
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        o_y &lt;= 'd0;
    end else begin
        o_y &lt;= sum_comb;
    end
end

function integer clogb2 (input integer depth);
    begin
        for(clogb2=0; depth&gt;1; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
    end
endfunction
endmodule
</code></pre>
<h4 id="仿真图">仿真图</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd537bba7194.png" alt="仿真图" title="仿真图" width=""> 
</center>
### 44
<p>注意其中非阻塞式赋值起到的关键作用。</p>
<h4 id="verilog描述-2">verilog描述</h4>
<pre><code class="language-verilog">module test44(
    input					clk			,
    input					rst_n		,
    input       [7:0]       i_data      ,
    output      [7:0]       o_y         
);
// y(n) = 0.75x(n) + 0.25y(n-1) 
//0.75*4 = 3，0.25*4 = 1

reg [9:0] dout;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        dout &lt;= 'd0;
    end else begin
        dout &lt;= 3*i_data + dout;
    end
end

assign o_y = dout&gt;&gt;2;

endmodule
</code></pre>
<h4 id="综合出的电路图">综合出的电路图</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd5832ecfddd.png" alt="44综合出的电路图" title="44综合出的电路图" width="800"> 
</center>
<h4 id="仿真结果">仿真结果</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd583f21bc1f.png" alt="44仿真结果" title="44仿真结果" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog没有葵花宝典——day10（PWM）]]></title>
        <id>https://halftop.github.io/post/verilog-day10</id>
        <link href="https://halftop.github.io/post/verilog-day10">
        </link>
        <updated>2019-05-08T09:05:52.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>用verilog实现PWM控制呼吸灯。呼吸周期2秒：1秒逐渐变亮，1秒逐渐变暗。系统时钟24MHz，pwm周期1ms，精度1us。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>用verilog实现PWM控制呼吸灯。呼吸周期2秒：1秒逐渐变亮，1秒逐渐变暗。系统时钟24MHz，pwm周期1ms，精度1us。</p>
</blockquote>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">Verilog描述</a></li>
<li><a href="#testbench">testbench</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E5%9B%BE">仿真图</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="思路">思路</h3>
<center>
 <img src="https://i.loli.net/2019/05/08/5cd29cc73330d.jpg" alt="思路（网图侵删）" title="思路（侵删）" width=""> 
</center>
<p>就不重复造轮子了，请点击 <a href="http://www.stepfpga.com/doc/%E5%91%BC%E5%90%B8%E7%81%AF">详细思路</a></p>
<h3 id="verilog描述">Verilog描述</h3>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: LED通过PWM调亮度,实现呼吸灯
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-08 11:24:52
// LastEditTime: 2019-05-08 16:08:10
// ********************************************************************
// Module Function:呼吸灯
`define SIMULATION;
module pwm_genrate
#(
    parameter CLK_FREQUENCE	= 24,	//MHz
            PWM_PRECISION	= 1,	//us
            PWM_PERIOD		= 1,	//ms
            BREATH_CYCLE	= 2		//s
)
(
    input					clk     ,
    input					rst_n	,
    output	reg				pwm_sig	
);

`ifdef	SIMULATION
localparam	PRECISION_CNT	= CLK_FREQUENCE*PWM_PRECISION,
            PERIOD_CNT		= PWM_PERIOD*10/PWM_PRECISION,
            CYCLE_CNT		= BREATH_CYCLE*5/PWM_PRECISION/PWM_PERIOD,
            PRECISION_WD	= clogb2(PRECISION_CNT),
            PERIOD_WD		= clogb2(PERIOD_CNT),
            CYCLE_WD		= clogb2(CYCLE_CNT);
`else
localparam	PRECISION_CNT	= CLK_FREQUENCE*PWM_PRECISION,
            PERIOD_CNT		= PWM_PERIOD*1000/PWM_PRECISION,
            CYCLE_CNT		= BREATH_CYCLE*500/PWM_PRECISION/PWM_PERIOD,
            PRECISION_WD	= clogb2(PRECISION_CNT),
            PERIOD_WD		= clogb2(PERIOD_CNT),
            CYCLE_WD		= clogb2(CYCLE_CNT);
`endif

reg     [PRECISION_WD-1:0]  cnt_pre;//精度计数
reg     [PERIOD_WD-1:0]     cnt_per;//pwm周期计数
reg     [CYCLE_WD-1:0]      cnt_cyc;//呼吸周期计数
wire                        time_pre;//精度标志
wire                        time_per;//pwm周期标志
wire                        time_cyc;//半个呼吸周期计数
reg                         turn_flag;//默认低亮高灭；1为逐渐变暗，0为逐渐变亮

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        cnt_pre &lt;= 'd0;
    end else if (cnt_pre&lt;PRECISION_CNT) begin
        cnt_pre &lt;= cnt_pre + 1'b1;
    end else begin
        cnt_pre &lt;= 'd1;
    end
end
assign time_pre = cnt_pre == PRECISION_CNT;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        cnt_per &lt;= 'd0;
    end else if (time_pre) begin
        cnt_per &lt;= (cnt_per&lt;PERIOD_CNT)?(cnt_per+1'b1):1'd1;
    end else begin
        cnt_per &lt;= cnt_per;
    end
end
assign time_per = cnt_per == PERIOD_CNT &amp;&amp; time_pre;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        cnt_cyc &lt;= 'd0;
    end else if (time_per) begin
        cnt_cyc &lt;= (cnt_cyc&lt;CYCLE_CNT)?(cnt_cyc+1'b1):1'd1;
    end else begin
        cnt_cyc &lt;= cnt_cyc;
    end
end
assign time_cyc = cnt_cyc == CYCLE_CNT &amp;&amp; time_per;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        turn_flag &lt;= 1'b0;
    end else if (time_cyc) begin
        turn_flag &lt;= ~turn_flag;
    end else begin
        turn_flag &lt;= turn_flag;
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        pwm_sig &lt;= 1'b1;
    end else begin
        case (turn_flag)
            1'b0: pwm_sig &lt;= (cnt_per&gt;cnt_cyc)?1'b1:1'b0;
            1'b1: pwm_sig &lt;= (cnt_per&lt;cnt_cyc)?1'b1:1'b0;
            default: pwm_sig &lt;= pwm_sig;
        endcase
    end
end

function integer clogb2 (input integer depth);
    begin
        for(clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
    end
endfunction
endmodule
</code></pre>
<h3 id="testbench">testbench</h3>
<pre><code class="language-verilog">module tb_pwm_led;
reg clk;
reg rst_n;
wire pwm_sig;

initial begin
    clk = 1;
    forever #1 clk = ~clk;
  end

initial begin
    rst_n = 1'b0;
    #22 rst_n = 1'b1;
    #20000 $finish;
  end

pwm_genrate
#(
    5,	//MHz
    1,	//us
    1,	//ms
    2		//s
)
pwm_led
(
    .clk		(clk	),
    .rst_n		(rst_n	),
    .pwm_sig	(pwm_sig)	
);
endmodule
</code></pre>
<h3 id="仿真图">仿真图</h3>
<center>
 <img src="https://i.loli.net/2019/05/08/5cd29e8d9fa40.png" alt="pwm呼吸灯仿真" title="pwm呼吸灯仿真" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog没有葵花宝典——day9（按键防抖）]]></title>
        <id>https://halftop.github.io/post/verilog-day9</id>
        <link href="https://halftop.github.io/post/verilog-day9">
        </link>
        <updated>2019-05-07T12:40:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>用verilog实现按键抖动消除电路，抖动小于15ms，输入时钟12MHz。</li>
<li>记录题目1中用到的工具，操作步骤，遇到的错误和提示信息。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>用verilog实现按键抖动消除电路，抖动小于15ms，输入时钟12MHz。</li>
<li>记录题目1中用到的工具，操作步骤，遇到的错误和提示信息。</li>
</ol>
</blockquote>
<!-- more --> 
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%A2%98">第一题</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">Verilog描述</a></li>
<li><a href="#testbench">testbench</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%A2%98">第二题</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="第一题">第一题</h2>
<p><strong>用verilog实现按键抖动消除电路，抖动小于15ms，输入时钟12MHz。</strong></p>
<h3 id="思路">思路</h3>
<p>假设按键按下时是低电平，松开时是高电平。监测按键由按下到松开整个过程，并用<code>key_vld</code>信号来表示x消抖后的按键输出。进一步可以输出按下、松开的有效信号（边沿检测），甚至可以按键计时。使用状态机完成，伪状态转移图：</p>
<center>
 <img src="https://i.loli.net/2019/05/07/5cd17f85ef647.jpg" alt="按键去抖状态转移图" title="按键去抖状态转移图" width="600"> 
</center>
<p>仿真图：</p>
<center>
 <img src="https://i.loli.net/2019/05/07/5cd1814a74fa3.png" alt="按键消抖仿真图" title="按键消抖仿真图" width=""> 
</center>
<h3 id="verilog描述">Verilog描述</h3>
<pre><code class="language-verilog">module debounce
#(
	parameter DELAY_TIME = 18'h3ffff
)
(
	input				clk,
	input				rst_n,
	input				key_in,
	output	reg			key_vld
);

localparam	IDLE		= 4'b0001,
			PRESS_DELAY	= 4'b0010,
			WAIT_RELEASE= 4'b0100,
			RELEASE_DELA= 4'b1000;

reg [1:0] key_in_r;
wire key_press_edge;
wire key_release_edge;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		key_in_r &lt;= 2'b11;
	end else begin
		key_in_r &lt;= {key_in_r[0],key_in};
	end
end
assign key_press_edge = key_in_r[1] &amp; (~key_in_r[0]);
assign key_release_edge = (~key_in_r[1]) &amp; key_in_r[0];


reg	[17:0]	  cnt;
reg [3:0] cstate,nstate;
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cstate &lt;= IDLE;
	end else begin
		cstate &lt;= nstate;
	end
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE	 : nstate = key_press_edge ? PRESS_DELAY : IDLE;
		PRESS_DELAY: begin
			if (cnt==DELAY_TIME &amp;&amp; key_in_r[0] == 0) begin
				nstate = WAIT_RELEASE;//按下完成
			end else if (cnt&lt;DELAY_TIME &amp;&amp; key_in_r[0] == 1) begin
				nstate = IDLE;//抖动
			end else begin
				nstate = PRESS_DELAY;//计数未完成
			end
		end
		WAIT_RELEASE: nstate = key_release_edge ? RELEASE_DELA : WAIT_RELEASE;
		RELEASE_DELA: begin
			if (cnt==DELAY_TIME &amp;&amp; key_in_r[0] == 1) begin
				nstate = IDLE;//松开完成
			end else if (cnt&lt;DELAY_TIME &amp;&amp; key_in_r[0] == 0) begin
				nstate = WAIT_RELEASE;//抖动
			end else begin
				nstate = RELEASE_DELA;//计数未完成
			end
		end
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		key_vld &lt;= 1'b1;
	end else begin
		case (nstate)
			IDLE,PRESS_DELAY:key_vld &lt;= 1'b1;
			WAIT_RELEASE,RELEASE_DELA: key_vld &lt;= 1'b0;
			default: key_vld &lt;= 1'b1;
		endcase
	end
end

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
		cnt &lt;= 18'd0;
    else if (cstate==PRESS_DELAY || cstate==RELEASE_DELA) begin
		if (cnt==DELAY_TIME) begin
			cnt &lt;= 18'd0;
		end else begin
			cnt &lt;= cnt + 1'b1;
		end
	end else begin
		cnt &lt;= 18'd0;
	end
end  
endmodule
</code></pre>
<h3 id="testbench">testbench</h3>
<pre><code class="language-verilog">module tb_debounce;
reg		clk		;
reg		rst_n	;
reg		key_in	;
wire	key_vld	;

initial begin
	clk = 1;
	forever #10 clk = ~clk;
  end

initial begin
	rst_n = 1'b0;
	#22 rst_n = 1'b1;
  end

initial begin
	key_in = 1'b1;
	repeat(15) begin
		@(posedge clk)
			key_in = {$random};
	end
	repeat(25) begin
		@(posedge clk)
			key_in = 1'b0;
	end
	repeat(25) begin
		@(posedge clk)
			key_in = 1'b1;
	end
	repeat(15) begin
		@(posedge clk)
			key_in = {$random};
	end
	$finish;
end

debounce
#(
	 'd10
)
debounce
(
	.clk		(clk	),
	.rst_n		(rst_n	),
	.key_in		(key_in	),
	.key_vld	(key_vld)	
);
endmodule
</code></pre>
<h2 id="第二题">第二题</h2>
<p>警告信息</p>
<p><code>Ignoring unknown option '-debug-all' passed to 'vcs' and continuing</code></p>
<p>原因是将<code>-debug_all</code>写出了<code>-debug-all</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog没有葵花宝典——day8（计数器）]]></title>
        <id>https://halftop.github.io/post/verilog-day8</id>
        <link href="https://halftop.github.io/post/verilog-day8">
        </link>
        <updated>2019-05-06T07:27:23.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>用verilog实现一个4bit二进制计数器。
a) 异步复位
b) 同步复位
input clk, rst_n;
output [3:0] o_cnt;</li>
<li>用verilog实现4bit约翰逊(Johnson)计数器。</li>
<li>用verilog实现4bit环形计数器：复位有效时输出0001，复位释放后依次输出0010，0100，1000，0001，0010...</li>
<li>比较一下以上三种计数器的特点。</li>
<li>记录1,2,3题目使用的工具，操作步骤，以及出现的错误和提示信息。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>用verilog实现一个4bit二进制计数器。
a) 异步复位
b) 同步复位
input clk, rst_n;
output [3:0] o_cnt;</li>
<li>用verilog实现4bit约翰逊(Johnson)计数器。</li>
<li>用verilog实现4bit环形计数器：复位有效时输出0001，复位释放后依次输出0010，0100，1000，0001，0010...</li>
<li>比较一下以上三种计数器的特点。</li>
<li>记录1,2,3题目使用的工具，操作步骤，以及出现的错误和提示信息。</li>
</ol>
</blockquote>
<!-- more --> 
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%A2%98">第一题</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">Verilog描述</a></li>
<li><a href="#vcs%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">vcs仿真结果</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%A2%98">第二题</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-2">Verilog描述</a></li>
<li><a href="#vcs%E4%BB%BF%E7%9C%9F">VCS仿真</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E9%A2%98">第三题</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-3">Verilog描述</a></li>
<li><a href="#vcs%E4%BB%BF%E7%9C%9F-2">VCS仿真</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E9%A2%98">第四题</a></li>
<li><a href="#%E7%AC%AC%E4%BA%94%E9%A2%98">第五题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="第一题">第一题</h3>
<p><strong>用verilog实现一个4bit二进制计数器。</strong></p>
<h4 id="verilog描述">Verilog描述</h4>
<pre><code class="language-verilog">module cnt2s(
    input clk, rst_n,
    output [3:0] o_cnt
    );
    reg [3:0] cnt;
//异步复位
/* always @ (posedge clk or negedge rst_n) begin
    if ( !rst_n )
        cnt &lt;= 4'b0000;
    else if ( cnt == 4'b1111 )
        cnt &lt;= 4'b0000;
    else
        cnt &lt;= cnt + 1'b1;
end */
//同步复位
always @ (posedge clk) begin
    if ( !rst_n )
        cnt &lt;= 4'b0000;
    else if ( cnt == 4'b1111 )
        cnt &lt;= 4'b0000;
    else
        cnt &lt;= cnt + 1'b1;
end

assign o_cnt = cnt;

endmodule
</code></pre>
<h4 id="vcs仿真结果">vcs仿真结果</h4>
<ul>
<li>同步复位</li>
</ul>
<center>
 <img src="https://i.loli.net/2019/05/06/5ccfee4f90f5a.png" alt="二进制计数器同步复位" title="二进制计数器同步复位" width=""> 
</center>
- 异步复位
<center>
 <img src="https://i.loli.net/2019/05/06/5ccfefa529217.png" alt="二进制计数器异步复位" title="二进制计数器异步复位" width=""> 
</center>
<h3 id="第二题">第二题</h3>
<p><strong>用verilog实现4bit约翰逊(Johnson)计数器。</strong></p>
<h4 id="verilog描述-2">Verilog描述</h4>
<pre><code class="language-verilog">module cnt_johnson(
    input clk, rst_n,
    output [3:0] o_cnt
    );
    reg [3:0] cnt;
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cnt &lt;= 4'b0000;
	end else begin
		cnt &lt;= {~cnt[0],cnt[3:1]};
	end
end

assign o_cnt = cnt;

endmodule
</code></pre>
<h4 id="vcs仿真">VCS仿真</h4>
<center>
 <img src="https://i.loli.net/2019/05/06/5ccfef4744096.png" alt="Johnson计数器" title="Johnson计数器" width=""> 
</center>
<h3 id="第三题">第三题</h3>
<p><strong>用verilog实现4bit环形计数器</strong></p>
<h4 id="verilog描述-3">Verilog描述</h4>
<pre><code class="language-verilog">module cnt_ring(
	input clk, rst_n,
    output [3:0] o_cnt
);
reg [3:0] cnt;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cnt &lt;= 4'b0001;
	end else begin
		cnt &lt;= {cnt[0],cnt[3:1]};
	end
end

assign o_cnt = cnt;
endmodule
</code></pre>
<h4 id="vcs仿真-2">VCS仿真</h4>
<center>
 <img src="https://i.loli.net/2019/05/06/5ccff040014cf.png" alt="4bit环形计数器" title="4bit环形计数器" width=""> 
</center>
#### testbench
<p>三个计数器均用此tb：</p>
<pre><code class="language-verilog">module tb_cnt4(    );
reg clk,rst_n;
wire [3:0]  o_cnt;

initial fork
  clk = 1'b0;
  rst_n = 1'b0;
  #20 rst_n = 1'b1;
  #455 rst_n = 1'b0;
  #475 rst_n = 1'b1;
  #600 $finish;
join

always #10 clk = ~ clk;

cnt**  cnt4(
    .clk    (clk  ),
    .rst_n  (rst_n),
    .o_cnt  (o_cnt)
    );
endmodule
</code></pre>
<h3 id="第四题">第四题</h3>
<p><strong>比较一下以上三种计数器的特点。</strong></p>
<ul>
<li>环形计数器：n比特的环形计数器会循环n次，每计数一次的汉明距离是2。一般来说，环形计数器中循环的数据是只有一个比特为1的数据，因此任一时刻只有一个触发器输出为高电位。</li>
<li>约翰逊记数器：是修改过的环形计数器，最后一个触发器的输出反相后再接到第一个触发器。n比特的环形计数器会循环2n次，每计数一次的<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>是1。电路译码是不会产生竞争冒险且译码电路简单。</li>
<li>二进制计数器：n位二进制计数器(n为触发器的个数)有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>个状态。</li>
</ul>
<p>参考链接：<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E5%99%A8#%E7%BA%A6%E7%BF%B0%E9%80%8A%E8%AE%B0%E6%95%B0%E5%99%A8">维基百科</a></p>
<p>另附一份更进一步解决前两种计数器自启动问题的<a href="https://wenku.baidu.com/view/0b116b23c1c708a1294a446e.html">文档</a></p>
<h3 id="第五题">第五题</h3>
<p>编辑器：VS Code，vim</p>
<p>仿真工具：VCS</p>
<pre><code class="language-shell">vcs ./tb.v ./cnt.v +v2k -debug_all -R -gui
</code></pre>
]]></content>
    </entry>
</feed>