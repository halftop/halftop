<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://halftop.github.io</id>
    <title>1/2顶点</title>
    <updated>2019-06-20T03:12:46.514Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://halftop.github.io"/>
    <link rel="self" href="https://halftop.github.io/atom.xml"/>
    <subtitle>    有输入有输出，才是正确的学习方式    </subtitle>
    <logo>https://halftop.github.io/images/avatar.png</logo>
    <icon>https://halftop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 1/2顶点</rights>
    <entry>
        <title type="html"><![CDATA[SPI协议及其Verilog实现]]></title>
        <id>https://halftop.github.io/post/Verilog_SPI</id>
        <link href="https://halftop.github.io/post/Verilog_SPI">
        </link>
        <updated>2019-06-16T11:50:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>SPI(Serial Peripheral Interface)是一个串行的同步传输协议，不同于Uart和IIC，没有起始位和结束位而是以时钟沿来同步和传输；不同于采用数据包的形式，数据可以连续不中断地传输。是一种一对多的传输协议。4线SPI是全双工的接口，而3线SPI是半双工接口，本篇采用更通用的4线SPI来介绍。</p>
<h3 id="接口">接口</h3>
<p>SPI总线有4根逻辑信号线：</p>
<ul>
<li>
<p><strong>SLCLK</strong>:串行时钟（由主机产生）</p>
</li>
<li>
<p><strong>SS/CS(Slave Select/Chip Select)</strong>:片选信号（由主机产生），通常是一个低电平有效信号</p>
</li>
<li>
<p><strong>MOSI (Master Output<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>Slave Input)</strong>:主机向从机的数据传输线</p>
</li>
<li>
<p><strong>MISO (Master Input<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span>Slave Output)</strong>:从机向主机的数据传输线</p>
</li>
</ul>
<h3 id="数据传输">数据传输</h3>
<p>要开始SPI通信，主机必须发送时钟信号，并通过使能CS信号选择从机。片选通常是低电平有效信号。因此，主机必须在该信号上发送逻辑0以选择从机。SPI是全双工接口，主机和从机可以分别通过MOSI和MISO线路同时发送数据。在SPI通信期间，数据的发送（串行移出到MOSI/SDO总线上）和接收（采样或读入总线(MISO/SDI)上的数据）同时进行。串行时钟沿同步数据的移位和采样。SPI接口允许灵活选择时钟的上升沿或下降沿来采样和/或移位数据。</p>
<h3 id="时钟极性和相位选择">时钟极性和相位选择</h3>
<p>主机除了要设置时钟频率，还要设置与数据传输相关的时钟极性和相位。大多数厂商都将这两个设置选项命名为<code>CPOL</code>和<code>CPHA</code>。</p>
<ul>
<li><code>CPOL</code>决定串行时钟极性。
<ul>
<li><code>CPOL=0</code>时钟在空闲时处于低电平，时钟的前沿是上升沿、后沿是下降沿。</li>
<li><code>CPOL=1</code>时钟在空闲时处于高电平，时钟的前沿是下降沿、后沿是上升沿。</li>
</ul>
</li>
<li><code>CPHA</code>
<ul>
<li><code>CPHA=0</code>时，发出数据的一边（ the &quot;out&quot; side）在前一时钟周期的后沿改变数据，同时接收数据的一方（ the &quot;in&quot; side ）在当前时钟周期的前沿捕获数据。<strong>注意</strong>：在第一个时钟周期，第一位数据必须在前沿到来之前出现在<code>MOSI</code>传输线上。</li>
<li><code>CPHA=1</code>时，发出数据的一边（ the &quot;out&quot; side）在当前时钟周期的前沿改变数据，同时接收数据的一方（ the &quot;out&quot; side）在同一时钟周期的后沿捕获数据。**注意：**在最后一个时钟周期，从机要在片选失效之前保持<code>MISO</code>线上的数据。</li>
</ul>
</li>
</ul>
<p>归纳起来如下图：</p>
<center>
 <img src="https://i.loli.net/2019/06/16/5d064c76df71274228.png" alt="通过CPOL和CPHA选择SPI模式" title="通过CPOL和CPHA选择SPI模式" width=""> 
</center>
<p>以上内容参考：<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Interface">Serial Peripheral Interface</a>、<a href="https://mp.weixin.qq.com/s/7HSgQOTpefBn4EryOYZ1Lg">一文读懂 4 线 SPI</a></p>
<p>如需了解更多信息，请点击上方链接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Uart的Verilog实现]]></title>
        <id>https://halftop.github.io/post/Verilog-Uart</id>
        <link href="https://halftop.github.io/post/Verilog-Uart">
        </link>
        <updated>2019-06-06T12:05:47.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>Uart是个缩写，全称是通用异步收发传输器（Universal Asynchronous Receiver/Transmitter）。单向传输只需要单线。异步传输的意思是没有同步时钟来同步发送端和接受端的数据，所以在数据之前添加起始位，之后添加结束位，以此来判断传输过程的开始和结束。当接收端检测到开始位，即开始以特定的频率来接收输入的bit位，这个特定的频率称为波特率。发送端和接收端要在大致相同的波特率下工作，才可以保证传输的正确性（最多相差10%）。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>Uart是个缩写，全称是通用异步收发传输器（Universal Asynchronous Receiver/Transmitter）。单向传输只需要单线。异步传输的意思是没有同步时钟来同步发送端和接受端的数据，所以在数据之前添加起始位，之后添加结束位，以此来判断传输过程的开始和结束。当接收端检测到开始位，即开始以特定的频率来接收输入的bit位，这个特定的频率称为波特率。发送端和接收端要在大致相同的波特率下工作，才可以保证传输的正确性（最多相差10%）。</p>
<!-- more -->
<h2 id="数据包的构成">数据包的构成</h2>
<p>Uart协议的传输数据被整合成数据包，每个数据包包含1位起始位，5-9位的数据位（具体决定于需求等因素），1位可选的奇偶校验位和1-2位的停止位。如下图所示：</p>
<center>
 <img src="https://i.loli.net/2019/06/07/5cf9cb2f3c5cd16813.png" alt="Uart数据包的构成" title="Uart数据包的构成" width="400"> 
</center>
<h3 id="起始位start-bit">起始位（start bit）</h3>
<p>数据传输线空闲的时候保持低电平，当开始传输时，拉低一个时钟周期，这就是起始位。当接受端检测到数据线由高到低的变化时便开始以约定的波特率来接收上述的数据包。</p>
<h3 id="数据帧data-frame">数据帧（data frame）</h3>
<p>这是实际需要传输的数据。如果使用奇偶校验功能的话，可以传输5-8位的数据；如果不使用奇偶校验功能，则可以传输9位。一般由最低位开始传输。</p>
<h3 id="奇偶校验位parity">奇偶校验位（parity）</h3>
<p>用于接收端判断接收到的数据的正误。当接受端接收到数据帧后，计算其中1的个数是奇数个还是偶数个。如果奇偶校验位是0(偶校验)，那么数据帧中1的个数应该是一个偶数。如果奇偶校验位是1(奇校验)，那么数据帧中1的个数应该是奇数。当奇偶校验位与数据匹配时，传输没有错误。但是如果奇偶校验位是0，但1的个数是奇数或者奇偶校验位是1，个数却是偶数，则数据传输过程中发生了变化。奇偶校验只有粗略判断正误的功能，没有改正的能力。</p>
<h3 id="停止位stop-bits">停止位（stop bits）</h3>
<p>高电平保持1-2个时钟周期表示1-2位停止位，即停止位为高电平。</p>
<p>以上参考：<a href="http://www.circuitbasics.com/basics-uart-communication/">BASICS OF UART COMMUNICATION</a></p>
<h2 id="波特率">波特率</h2>
<h3 id="波特率和比特率">波特率和比特率</h3>
<p>比特率：每秒钟传输的二进制位数（bit），表示有效数据的传输速率，单位是b/s 、bit/s、比特/秒，读作：比特每秒。</p>
<p>波特率：波特率可以被理解为单位时间内传输符号的个数（传符号率），通过不同的调制方法可以在一个符号上负载多个比特信息。</p>
<p>比特率和波特率在数值上有如下关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>S</mi><mo>⋅</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">I=S \cdot \log _{2} N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p>其中***I*** 为传信率（比特率），<em><strong>S</strong></em> 为波特率，<em><strong>N</strong></em> 为每个符号负载的信息量，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log _{2} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>以比特为单位。</p>
<p>以RS232为例，假设目前“<strong>波特率</strong>”为 9600， 则此RS232的比特率计算为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo>=</mo><mi>S</mi><mo>⋅</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>N</mi><mo>=</mo><mn>9600</mn><mo>⋅</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mn>2</mn><mo>=</mo><mn>9600</mn><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">I=S \cdot \log _{2} N=9600 \cdot \log _{2} 2=9600 b i t / s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>常有人把RS232之<em>N</em> 误以为是每个“<strong>符号</strong>”（symbol）所夹带的讯息量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>，但实际上每一个“<strong>位元</strong>”（bit）即为一个“<strong>符号</strong>”（symbol）。</p>
<p>计算机通信中，波特率与比特率虽在数值上相等，但是它们的意义并不相同。</p>
<p>以上参考：<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">波特率</a></p>
<h3 id="常见波特率">常见波特率</h3>
<p>9600、19200 、38400 、57600 、115200、230400、460800、921600</p>
<h3 id="时钟与波特率的计算">时钟与波特率的计算</h3>
<p>FPGA 主频如果为50M，则时钟周期就是20ns。若数据发送速率为9600bps，则一位数据需要的时间为1000000000/9600=104167ns，则FPGA 传送一位需要翻转104167/20=5208个周期才可传送一位，所以程序中需计数5208才可满足9600bps。</p>
<p>简单一点就是***时钟频率除以波特率***就是需要的计数。</p>
<h2 id="verilog模块详解">Verilog模块详解</h2>
<p><a href="https://github.com/halftop/verilog_uart">全部rtl和tb</a></p>
<p><a href="https://www.cnblogs.com/xiaomeige/p/6390246.html">参考链接</a>，建议固定位宽和不需要奇偶校验，使用此博文中的简洁描述</p>
<h3 id="tx_clk_genv">tx_clk_gen.v</h3>
<p>发送波特率生成模块，在<code>tx_start</code>和<code>tx_done</code>两信号有效的间隙生成选择的波特率时钟信号。思路如上一节所述！</p>
<p>支持的波特率：9600、19200 、38400 、57600 、115200、230400、460800、921600，可由参数配置。</p>
<p>相应Verilog描述：</p>
<pre><code class="language-verilog">`timescale 1ns / 1ps
module tx_clk_gen
#(
	parameter	CLK_FREQUENCE	= 50_000_000,		//hz
				BAUD_RATE		= 9600		 		//9600、19200 、38400 、57600 、115200、230400、460800、921600
)
(
	input					clk			,	//system_clk
	input					rst_n		,	//system_reset
	input					tx_done		,	//once_tx_done
	input					tx_start	,	//once_tx_start
	output	reg				bps_clk		 	//baud_rate_clk
);

localparam	BPS_CNT	=	CLK_FREQUENCE/BAUD_RATE-1,
			BPS_WD	=	log2(BPS_CNT);

reg	[BPS_WD-1:0] count;
reg c_state;
reg n_state;
//FSM-1			1'b0:IDLE	1'b1:send_data
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		c_state &lt;= 1'b0;
	else
		c_state &lt;= n_state;
end
//FSM-2
always @(*) begin
	case (c_state)
		1'b0: n_state = tx_start ? 1'b1 : 1'b0;
		1'b1: n_state = tx_done ? 1'b0 : 1'b1;
		default: n_state = 1'b0;
	endcase
end
//FSM-3 FSM's output(count_en) is equal to c_state

//baud_rate_clk_counter
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		count &lt;= {BPS_WD{1'b0}};
	else if (!c_state)
		count &lt;= {BPS_WD{1'b0}};
	else begin
		if (count == BPS_CNT) 
			count &lt;= {BPS_WD{1'b0}};
		else
			count &lt;= count + 1'b1;
	end
end
//baud_rate_clk_output
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		bps_clk &lt;= 1'b0;
	else if (count == 'd1)
		bps_clk &lt;= 1'b1;
	else
		bps_clk &lt;= 1'b0;
end
//get_the_width_of_
function integer log2(input integer v);
  begin
	log2=0;
	while(v&gt;&gt;log2) 
	  log2=log2+1;
  end
endfunction

endmodule
</code></pre>
<h3 id="uart_frame_txv">uart_frame_tx.v</h3>
<p>数据帧发送模块，支持通过参数设定波特率、奇偶检验位及数据位宽。采用状态机和移位寄存器实现。当有校验位时则发送检验位；若没有校验位则直接发送停止位（发送两次停止位），如下所示。</p>
<pre><code class="language-verilog">`timescale 1ns / 1ps
module uart_frame_tx
#(
	parameter	CLK_FREQUENCE	= 50_000_000,		//hz
				BAUD_RATE		= 9600		,		//9600、19200 、38400 、57600 、115200、230400、460800、921600
				PARITY			= &quot;NONE&quot;	,		//&quot;NONE&quot;,&quot;EVEN&quot;,&quot;ODD&quot;
				FRAME_WD		= 8					//if PARITY=&quot;NONE&quot;,it can be 5~9;else 5~8
)
(
	input						clk			,	//system_clk
	input						rst_n		,	//system_reset
	input						frame_en	,	//once_tx_start
	input		[FRAME_WD-1:0]	data_frame	,	//data_to_tx
	output	reg					tx_done		,	//once_tx_done
	output	reg					uart_tx		 	//uart_tx_data
);

wire	bps_clk;

tx_clk_gen
#(
	.CLK_FREQUENCE	(CLK_FREQUENCE),		//hz
	.BAUD_RATE		(BAUD_RATE	)	 		//9600、19200 、38400 、57600 、115200、230400、460800、921600
)
tx_clk_gen_inst
(
	.clk			( clk		 ),		//system_clk
	.rst_n			( rst_n		 ),		//system_reset
	.tx_done		( tx_done	 ),		//once_tx_done
	.tx_start		( frame_en	 ),		//once_tx_start
	.bps_clk		( bps_clk	 ) 		//baud_rate_clk
);

localparam	IDLE		=	6'b00_0000	,
			READY		=	6'b00_0001	,
			START_BIT	=	6'b00_0010	,
			SHIFT_PRO	=	6'b00_0100	,
			PARITY_BIT	=	6'b00_1000	,
			STOP_BIT	=	6'b01_0000	,
			DONE		=	6'b10_0000	;

wire	[1:0]	verify_mode;
generate
	if (PARITY == &quot;ODD&quot;)
		assign verify_mode = 2'b01;
	else if (PARITY == &quot;EVEN&quot;)
		assign verify_mode = 2'b10;
	else
		assign verify_mode = 2'b00;
endgenerate

reg		[FRAME_WD-1:0]	data_reg	;
reg		[log2(FRAME_WD-1)-1:0] cnt	;
reg						parity_even	;
reg 	[5:0]			cstate		;
reg		[5:0]			nstate		;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		cnt &lt;= 'd0;
	else if (cstate == SHIFT_PRO &amp; bps_clk == 1'b1) 
		if (cnt == FRAME_WD-1)
			cnt &lt;= 'd0;
		else
			cnt &lt;= cnt + 1'b1;
	else
		cnt &lt;= cnt;
end
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n)
		cstate &lt;= IDLE;
	else
		cstate &lt;= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE		: nstate = frame_en ? READY : IDLE	;
		READY		: nstate = (bps_clk == 1'b1) ? START_BIT : READY;
		START_BIT	: nstate = (bps_clk == 1'b1) ? SHIFT_PRO : START_BIT;
		SHIFT_PRO	: nstate = (cnt == FRAME_WD-1 &amp; bps_clk == 1'b1) ? PARITY_BIT : SHIFT_PRO;
		PARITY_BIT	: nstate = (bps_clk == 1'b1) ? STOP_BIT : PARITY_BIT;
		STOP_BIT	: nstate = (bps_clk == 1'b1) ? DONE : STOP_BIT;
		DONE		: nstate = IDLE;
		default		: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		data_reg &lt;= 'd0;
		uart_tx &lt;= 1'b1;
		tx_done &lt;= 1'b0;
		parity_even &lt;= 1'b0;
	end else begin
		case (nstate)
			IDLE		: begin
							data_reg &lt;= 'd0;
							tx_done &lt;= 1'b0;
							uart_tx &lt;= 1'b1;
						end
			READY		: begin
							data_reg &lt;= 'd0;
							tx_done &lt;= 1'b0;
							uart_tx &lt;= 1'b1;
						end
			START_BIT	: begin
							data_reg &lt;= data_frame;
							parity_even &lt;= ^data_frame;		//生成偶校验位
							uart_tx &lt;= 1'b0;
							tx_done &lt;= 1'b0;
						end
			SHIFT_PRO	: begin
							if(bps_clk == 1'b1) begin
								data_reg &lt;= {1'b0,data_reg[FRAME_WD-1:1]};
								uart_tx &lt;= data_reg[0];
							end else begin
								data_reg &lt;= data_reg;
								uart_tx &lt;= uart_tx;
							end
							tx_done &lt;= 1'b0;
						end
			PARITY_BIT	: begin
							data_reg &lt;= data_reg;
							tx_done &lt;= 1'b0;
							case (verify_mode)
								2'b00: uart_tx &lt;= 1'b1;		//若无校验多发一位STOP_BIT
								2'b01: uart_tx &lt;= ~parity_even;
								2'b10: uart_tx &lt;= parity_even;
								default: uart_tx &lt;= 1'b1;
							endcase
						end
			STOP_BIT	: uart_tx &lt;= 1'b1;
			DONE		: tx_done &lt;= 1'b1;
			default		:  begin
							data_reg &lt;= 'd0;
							uart_tx &lt;= 1'b1;
							tx_done &lt;= 1'b0;
							parity_even &lt;= 1'b0;
						end
		endcase
	end
end

function integer log2(input integer v);
  begin
	log2=0;
	while(v&gt;&gt;log2) 
	  log2=log2+1;
  end
endfunction

endmodule
</code></pre>
<h3 id="uart_frame_rxv">uart_frame_rx.v</h3>
<p>数据接收模块的主要描述如下：</p>
<pre><code class="language-verilog">module uart_frame_rx
#(
	parameter	CLK_FREQUENCE	= 50_000_000,		//hz
				BAUD_RATE		= 9600		,		//9600、19200 、38400 、57600 、115200、230400、460800、921600
				PARITY			= &quot;NONE&quot;	,		//&quot;NONE&quot;,&quot;EVEN&quot;,&quot;ODD&quot;
				FRAME_WD		= 8					//if PARITY=&quot;NONE&quot;,it can be 5~9;else 5~8
)
(
	input						clk			,		//sys_clk
	input						rst_n		,		
	input						uart_rx		,		
	output	reg	[FRAME_WD-1:0]	rx_frame	,		//frame_received,when rx_done = 1 it's valid
	output	reg					rx_done		,		//once_rx_done
	output	reg					frame_error	 		//when the PARITY is enable if frame_error = 1,the frame received is wrong
);

wire			sample_clk		;
wire			frame_en		;		//once_rx_start
reg				cnt_en			;		//sample_clk_cnt enable
reg		[3:0]	sample_clk_cnt	;		
reg		[log2(FRAME_WD+1)-1:0]		sample_bit_cnt	;
wire			baud_rate_clk	;

localparam	IDLE		=	5'b0_0000,
			START_BIT	=	5'b0_0001,
			DATA_FRAME	=	5'b0_0010,
			PARITY_BIT	=	5'b0_0100,
			STOP_BIT	=	5'b0_1000,
			DONE		=	5'b1_0000;

reg	[4:0]	cstate;
reg [4:0]	nstate;
//
wire	[1:0]	verify_mode;
generate
	if (PARITY == &quot;ODD&quot;)
		assign verify_mode = 2'b01;
	else if (PARITY == &quot;EVEN&quot;)
		assign verify_mode = 2'b10;
	else
		assign verify_mode = 2'b00;
endgenerate
//detect the start condition--the negedge of uart_rx
reg		uart_rx0,uart_rx1,uart_rx2,uart_rx3;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		uart_rx0 &lt;= 1'b0;
		uart_rx1 &lt;= 1'b0;
		uart_rx2 &lt;= 1'b0;
		uart_rx3 &lt;= 1'b0;
	end else begin
		uart_rx0 &lt;= uart_rx ;
		uart_rx1 &lt;= uart_rx0;
		uart_rx2 &lt;= uart_rx1;
		uart_rx3 &lt;= uart_rx2;
	end
end
//negedge of uart_rx-----start_bit
assign frame_en = uart_rx3 &amp; uart_rx2 &amp; ~uart_rx1 &amp; ~uart_rx0;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cnt_en &lt;= 1'b0;
	else if (frame_en) 
		cnt_en &lt;= 1'b1;
	else if (rx_done) 
		cnt_en &lt;= 1'b0;
	else
		cnt_en &lt;= cnt_en;
end

assign baud_rate_clk = sample_clk &amp; sample_clk_cnt == 4'd8;

always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sample_clk_cnt &lt;= 4'd0;
	else if (cnt_en) begin
		if (baud_rate_clk) 
			sample_clk_cnt &lt;= 4'd0;
		else if (sample_clk)
			sample_clk_cnt &lt;= sample_clk_cnt + 1'b1;
		else
			sample_clk_cnt &lt;= sample_clk_cnt;
	end else 
		sample_clk_cnt &lt;= 4'd0;
end
//the start_bit is the first one (0),then the LSB of the data_frame is the second(1) ......
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sample_bit_cnt &lt;= 'd0;
	else if (cstate == IDLE)
		sample_bit_cnt &lt;= 'd0;
	else if (baud_rate_clk)
		sample_bit_cnt &lt;= sample_bit_cnt + 1'b1;
	else
		sample_bit_cnt &lt;= sample_bit_cnt;
end
//read the readme
reg		[1:0]	sample_result	;
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sample_result &lt;= 1'b0;
	else if (sample_clk) begin
		case (sample_clk_cnt)
			4'd0:sample_result &lt;= 2'd0;
			4'd3,4'd4,4'd5: sample_result &lt;= sample_result + uart_rx;
			default: sample_result &lt;= sample_result;
		endcase
	end
end
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cstate &lt;= IDLE;
	else 
		cstate &lt;= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE		: nstate = frame_en ? START_BIT : IDLE ;
		START_BIT	: nstate = (baud_rate_clk &amp; sample_result[1] == 1'b0) ? DATA_FRAME : START_BIT ;
		DATA_FRAME	: begin
						case (verify_mode[1]^verify_mode[0])
							1'b1: nstate = (sample_bit_cnt == FRAME_WD &amp; baud_rate_clk) ? PARITY_BIT : DATA_FRAME ;		//parity is enable
							1'b0: nstate = (sample_bit_cnt == FRAME_WD &amp; baud_rate_clk) ? STOP_BIT : DATA_FRAME ;		//parity is disable
							default: nstate = (sample_bit_cnt == FRAME_WD &amp; baud_rate_clk) ? STOP_BIT : DATA_FRAME ;	//defasult is disable
						endcase
					end
		PARITY_BIT	: nstate = baud_rate_clk ? STOP_BIT : PARITY_BIT ;
		STOP_BIT	: nstate = (baud_rate_clk &amp; sample_result[1] == 1'b1) ? DONE : STOP_BIT ;
		DONE		: nstate = IDLE;
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		rx_frame	&lt;= 'd0;
		rx_done		&lt;= 1'b0;
		frame_error	&lt;= 1'b0;
	end else begin
		case (nstate)
			IDLE		: begin
							rx_frame	&lt;= 'd0;
							rx_done		&lt;= 1'b0;
							frame_error	&lt;= 1'b0;
						end 
			START_BIT	: begin
							rx_frame	&lt;= 'd0;
							rx_done		&lt;= 1'b0;
							frame_error	&lt;= 1'b0;
						end 
			DATA_FRAME	: begin
							if (sample_clk &amp; sample_clk_cnt == 4'd6) 
								rx_frame &lt;= {sample_result[1],rx_frame[FRAME_WD-1:1]};
							else
								rx_frame	&lt;= rx_frame;
							rx_done		&lt;= 1'b0;
							frame_error	&lt;= 1'b0;
						end 
			PARITY_BIT	: begin
							rx_frame	&lt;= rx_frame;
							rx_done		&lt;= 1'b0;
							if (sample_clk_cnt == 4'd8)
							frame_error	&lt;= ^rx_frame ^ sample_result[1];
							else
							frame_error	&lt;= frame_error;
						end 
			STOP_BIT	: begin
							rx_frame	&lt;= rx_frame;
							rx_done		&lt;= 1'b0;
							frame_error	&lt;= frame_error;
						end 
			DONE		: begin
							frame_error	&lt;= frame_error;
							rx_done		&lt;= 1'b1;
							rx_frame	&lt;= rx_frame;
						end 
			default: begin
							rx_frame	&lt;= rx_frame;
							rx_done		&lt;= 1'b0;
							frame_error	&lt;= frame_error;
						end 
		endcase
	end
end

rx_clk_gen
#(
	.CLK_FREQUENCE	(CLK_FREQUENCE	),	//hz
	.BAUD_RATE		(BAUD_RATE		)	//9600、19200 、38400 、57600 、115200、230400、460800、921600
)
rx_clk_gen_inst
(
	.clk			( clk		 )	,
	.rst_n			( rst_n		 )	,
	.rx_start		( frame_en	 )	,
	.rx_done		( rx_done	 )	,
	.sample_clk	 	( sample_clk )	
);	

function integer log2(input integer v);
  begin
	log2=0;
	while(v&gt;&gt;log2) 
	  log2=log2+1;
  end
endfunction
endmodule
</code></pre>
<p>根据uart协议，数据传输线空闲时位高电平，数据传输以一位低电平的起始位开始，因此准确检测起始位是数据成功传输的关键。由于接受端和发送端是异步的，需要专门的边沿检测电路来捕捉下降沿。这里采用4个移位寄存器，连续采集4个时钟上升沿时的数据，通过对比前两个时刻和后两个时刻的数据线的状态来得到数据线准确的下降沿，获得准确的开始接收条件。</p>
<p>在简单的串口接收中，我们通常选取一位数据的中间时刻进行采样，因为此时数据最稳定，但是在工业环境中，存在着各种干扰，在干扰存在的情况下，如果采用传统的中间时刻采样一次的方式，采样结果就有可能受到干扰而出错。为了滤除这种干扰，这里采用多次采样求概率的方式。如下图，将一位数据平均分成9个时间段，对位于中间的三个时间段进行采样。然后对三个采样结果进行统计判断，如果某种电平状态在三次采样结果中占到了两次及以上，则可以判定此电平状态即为正确的数据电平。例如4、5、6时刻采样结果分别为1、1、0，那么就取此位解码结果为1，否则，若三次采样结果为0、1、0，则解码结果就为0。即3次采样为a,b,c，则结果为<code>a&amp;b | b&amp;c |a&amp;c</code>，显而易见此结果是全加器的进位，<a href="https://halftop.github.io/post/verilog99_12to21/#%E9%A2%98%E7%9B%AE012">参考链接</a>。</p>
<center>
 <img src="https://i.loli.net/2019/06/11/5cffa2289f6cb31791.png" alt="数据采样示例" title="数据采样示例" width="600"> 
</center>
<h3 id="rx_clk_genv">rx_clk_gen.v</h3>
<p>所以采样时钟应该为波特率时钟的9倍，Verilog描述如下：</p>
<pre><code class="language-verilog">`timescale 1ns / 1ps

module rx_clk_gen
#(
	parameter	CLK_FREQUENCE	= 50_000_000,	//hz
				BAUD_RATE		= 9600		 	//9600、19200 、38400 、57600 、115200、230400、460800、921600
)
(
	input					clk			,
	input					rst_n		,
	input					rx_start	,
	input					rx_done		,
	output	reg				sample_clk	 
);

localparam	SMP_CLK_CNT	=	CLK_FREQUENCE/BAUD_RATE/9 - 1,
			CNT_WIDTH	=	log2(SMP_CLK_CNT)			 ;

reg		[CNT_WIDTH-1:0]	clk_count	;
reg		cstate;
reg		nstate;
//FSM-1	1'b0:IDLE 1'b1:RECEIVE
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cstate &lt;= 1'b0;
	end else begin
		cstate &lt;= nstate;
	end
end
//FSM-2
always @(*) begin
	case (cstate)
		1'b0: nstate = rx_start ? 1'b1 : 1'b0;
		1'b1: nstate = rx_done ? 1'b0 : 1'b1 ;
		default: nstate = 1'b0;
	endcase
end
//FSM-3 FSM's output(clk_count_en) is equal to cstate

//sample_clk_counter
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		clk_count &lt;= 'd0;
	else if (!cstate) 
		clk_count &lt;= 'd0;
	else if (clk_count == SMP_CLK_CNT)
		clk_count &lt;= 'd0;
	else
		clk_count &lt;= clk_count + 1'b1;
end
//generate sample_clk = 9xBAUD_RATE
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sample_clk &lt;= 1'b0;
	else if (clk_count == 1'b1) 
		sample_clk &lt;= 1'b1;
	else 
		sample_clk &lt;= 1'b0;
end
//get the width of sample_clk_counter
function integer log2(input integer v);
  begin
	log2=0;
	while(v&gt;&gt;log2) 
	  log2=log2+1;
  end
endfunction

endmodule
</code></pre>
<h2 id="总结">总结</h2>
<p>顾及的功能太多，比如奇偶校验，位宽设定等，最终的描述不简洁。但是功能基本都实现了，把思路和代码沉淀在这里。Verilog和本文多处借鉴他人成果，都已给出参考链接，侵删。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-FIFO设计]]></title>
        <id>https://halftop.github.io/post/verilog99_FIFO</id>
        <link href="https://halftop.github.io/post/verilog99_FIFO">
        </link>
        <updated>2019-06-03T14:00:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的58-61题是关于FIFO设计，包括同步FIFO，异步FIFO和FIFO最小深度计算等问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的58-61题是关于FIFO设计，包括同步FIFO，异步FIFO和FIFO最小深度计算等问题。</p>
<!-- more --> 
<h2 id="同步fifo设计">同步FIFO设计</h2>
<p>因为同步 FIFO 的读写速率是相同的，所以 FIFO 的大小设置不必考虑读写速率差和跨时钟域等问题，要简单很多。</p>
<blockquote>
<p>在 FIFO 内部，一般使用 dual port RAM 存储数据。双端口 RAM 有两套独立的读写地址，读地址和写地址分别由读指针和写指针来产生：写指针指向下一个数据被写入的地址，读指针指向下一个被读出的数据的地址，通过判断读写指针的相对大小，就可以得到 FIFO 的状态（full / empty）。</p>
</blockquote>
<blockquote>
<p>还有另外一种方法来产生 full / empty 信号：FIFO 内部维护一个计数器，每次写入一个数据 cnt++，每次读出一个数据 cnt--。这种方法产生 full / empty 很简单：当 cnt == 0，表示 FIFO empty；当 cnt == max，表示 FIFO full。虽然这种方法产生 full / empty 很简单，但是需要额外的计数器，而且计数器的位宽随着 FIFO 的深度增加，不仅占用的资源更多，而且会降低 FIFO 最终可以达到的速度。</p>
</blockquote>
<p>所以这里采用第一种方法实现。</p>
<h3 id="思路">思路</h3>
<p>调用34题的dual port SRAM来实现。</p>
<p>深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>的FIFO，为读、写地址指针多添加一个额外的位。当写指针超过最后的FIFO地址时，写指针将使未使用的MSB（Most Significant Bit的缩写，指最高有效位）递增，同时将其余的位设置为零，如下图所示（FIFO已经回环并翻转指针的MSB位）。</p>
<center>
 <img src="https://i.loli.net/2019/06/03/5cf52d50cb32615601.png" alt="空满状态判别" title="空满状态判别" width="700"> 
</center>
<p>读指针的操作与此类似，如果两个指针的MSB不同，则意味着写指针已经发生了回环。如果两个指针的MSB相同，则意味着两个指针都回环了相同的次数。</p>
<p>对于深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>的FIFO，使用n位指针，其中（n-1）bit是访问整个FIFO存储器缓冲区所需的地址位数，当两个指针（包括MSB）相等时，FIFO为空；当两个指针（MSB除外）相等时，FIFO就会满。</p>
<center>
 <img src="https://i.loli.net/2019/06/03/5cf53115e6ab143290.png" alt="FIFO的深度为8，需要用宽度为4的指针" title="FIFO的深度为8，我们需要用宽度为4的指针" width=""> 
</center>
<p>读写指针的关系就好比A,B两个田径运动员在一环形跑道上赛跑一样，当B运动员领先A并整整超前一圈时，A,B两人的地点相同，此种情况对应于读写指针指向了同一地址，但写指针超前整整一圈，FIFO被写满。和读空标志产生一样，写满标志也是读写指针相同时产生。但是如果地址的宽度和FIFO实际深度所需的宽度相等，某一时刻读写地址相同了，那FIFO是空还是满就难以判断了。所以读写指针需要增加一位来标记写地址是否超前读地址（在系统正确工作的前提下，读地址不可能超前于写地址），比如FIFO的深度为8，如上图所示需要用宽度为4的指针。</p>
<h3 id="verilog描述testbench">Verilog描述&amp;testbench</h3>
<p><a href="https://github.com/halftop/code_of_Verilog_HDL99/blob/master/sources_1/new/test58.v">verilog</a></p>
<p><a href="https://github.com/halftop/code_of_Verilog_HDL99/blob/master/sim_1/new/tb58.v">testbench</a></p>
<p><a href="https://github.com/halftop/code_of_Verilog_HDL99/tree/master/sources_1/new/test_58_refrence">verilog_refrence</a></p>
<h3 id="参考链接">参考链接</h3>
<p><a href="http://guqian110.github.io/pages/2015/10/02/fifo_design_notes.html">FIFO 设计笔记</a></p>
<p><a href="http://www.sohu.com/a/114158723_458015">异步FIFO设计</a></p>
<h2 id="异步fifo设计">异步FIFO设计</h2>
<p>。。。。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-57题]]></title>
        <id>https://halftop.github.io/post/verilog99-57</id>
        <link href="https://halftop.github.io/post/verilog99-57">
        </link>
        <updated>2019-05-27T09:23:20.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>在clk a时钟域的一个单周期脉冲信号，如何正确的传递到clk b时钟域? 要考虑clk a和b的各种不同频率/相位的场景。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<p>在clk a时钟域的一个单周期脉冲信号，如何正确的传递到clk b时钟域? 要考虑clk a和b的各种不同频率/相位的场景。</p>
</blockquote>
<!-- more --> 
<h2 id="总结">总结</h2>
<p>关于单bit信号的跨时钟域传输<a href="https://www.cnblogs.com/IClearner/p/6485389.html">这篇博客</a>总结的比较详细，这里直接copy一下结论：</p>
<blockquote>
<ul>
<li>在跨时钟域的时候，不一定需要跨时钟域电路（同步器或者握手信号），接近异步时钟或者就是异步时钟的时候跨时钟域就得加上了。</li>
<li>在慢到快的时钟域中，加上触发器链（两级触发器）基本上就可以了，主要是抑制亚稳态的传播。</li>
<li>但是在快到慢的时钟域中，不仅需要触发器链进行抑制亚稳态的传播，还要防止慢时钟域采不到快时钟域的数据，因此就添加反馈/握手电路（这个反馈信号是指跨时钟域的反馈信号）。（可以使用脉冲展宽）</li>
</ul>
</blockquote>
<h2 id="verilog描述">Verilog描述</h2>
<p>参考了<a href="https://wx.zsxq.com/dweb/#/index/458811454428"><strong>NingHeChua*</strong></a>的描述</p>
<h3 id="慢时钟域到快时钟域两级寄存器同步">慢时钟域到快时钟域，两级寄存器同步</h3>
<pre><code class="language-verilog">module Sync_Pulse(
        input           clkb,
        input           rst_n,
        input           pulse_ina,
        output          pulse_outb
    );
    
    reg	signal_r;
    reg signal_rr;
    
    always @ (posedge clkb or negedge rst_n)
        if (!rst_n) begin
           signal_r &lt;= 1'b0;
           signal_rr &lt;= 1'b0;
        end else begin
           signal_r &lt;= pulse_ina;
           signal_rr &lt;= signal_r;
        end
    assign pulse_outb = signal_rr;
endmodule
</code></pre>
<h3 id="快时钟域到慢时钟域">快时钟域到慢时钟域</h3>
<pre><code class="language-verilog">module Sync_Pulse(
    input           clka,
    input           clkb,
    input           rst_n,
    input           pulse_ina,
    output          pulse_outb,
    output          signal_outb
);
//-------------------------------------------------------
reg             signal_a;
reg             signal_b;
reg             signal_b_r;
reg             signal_b_rr;
reg             signal_a_r;
reg             signal_a_rr;
//-------------------------------------------------------
//在clka下，生成展宽信号signal_a
always @(posedge clka or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_a &lt;= 1'b0;
    end
    else if(pulse_ina == 1'b1)begin
        signal_a &lt;= 1'b1;
    end
    else if(signal_a_rr == 1'b1)
        signal_a &lt;= 1'b0;
    else 
        signal_a &lt;= signal_a;
end
//-------------------------------------------------------
//在clkb下同步signal_a
always @(posedge clkb or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_b &lt;= 1'b0;
    end
    else begin
        signal_b &lt;= signal_a;
    end
end
//-------------------------------------------------------
//在clkb下生成脉冲信号和输出信号
always @(posedge clkb or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_b_r &lt;= 'b0;
        signal_b_rr &lt;= 'b0;
    end
    else begin
        signal_b_rr &lt;= signal_b_r;
        signal_b_r &lt;= signal_b;
    end
end
assign    pulse_outb = ~signal_b_rr &amp; signal_b_r;
assign    signal_outb = signal_b_rr;
//-------------------------------------------------------
//在clka下采集signal_b_rr，生成signal_a_rr用于反馈拉低signal_a
always @(posedge clka or negedge rst_n)begin
    if(rst_n == 1'b0)begin
        signal_a_r &lt;= 'b0;
        signal_a_rr &lt;= 'b0;
    end
    else begin
        signal_a_rr &lt;= signal_a_r;
        signal_a_r &lt;= signal_b_rr;
    end
end
endmodule
</code></pre>
<center>
 <img src="https://i.loli.net/2019/05/27/5cebb39c27a3271351.png" alt="rtl图" title="rtl图" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AMBA-APB总线协议学习]]></title>
        <id>https://halftop.github.io/post/amba-apb</id>
        <link href="https://halftop.github.io/post/amba-apb">
        </link>
        <updated>2019-05-22T11:58:34.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>The Advanced Peripheral Bus(APB)is part of the Advanced Microcontroller Bus architecture (AMBA)protocol family. It defines a low-cost interface that is optimized for minimal consumption and reduced interface complexity.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<blockquote>
<p>The Advanced Peripheral Bus(APB)is part of the Advanced Microcontroller Bus architecture (AMBA)protocol family. It defines a low-cost interface that is optimized for minimal consumption and reduced interface complexity.</p>
</blockquote>
<!-- more -->
<blockquote>
<p>The APB protocol is not pipelined, use it to connect to low-bandwidth peripherals that do not require the high performance of the AXI protocol.</p>
<p>The APB protocol relates a signal transition to the rising edge of the clock, to simplify the integration of APB peripherals into any design flow. Every transfer takes at least two cycles.</p>
<p>The APB can interface with :</p>
<ul>
<li>
<p>AMBA Advanced High-performance Bus (AHB)</p>
</li>
<li>
<p>AMBA Advanced High-performance Bus Lite (AHB-Lite)</p>
</li>
<li>
<p>AMBA Advanced Extensible Interface (AXI)</p>
</li>
<li>
<p>AMBA Advanced Extensible Interface Lite (ax4-Lite)</p>
</li>
</ul>
<p>You can use it to access the programmable control registers of peripheral devices.</p>
</blockquote>
<h2 id="版本">版本</h2>
<ol>
<li>The APB Specification Rev E, released in 1998（过时）</li>
<li>AMBA 2 APB Specification</li>
<li>AMBA 3 APB Protocol Specification v1.0</li>
<li>AMBA APB Protocol Specification v2.0.</li>
</ol>
<h2 id="信号">信号</h2>
<p>英语通俗易懂。</p>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce549f1335d014773.png" alt="APB signal descriptions" title="APB signal descriptions" width="900"> 
</center>
<p>简要翻译一下，建议看上方英文原版。</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>来源</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCLK</td>
<td>时钟源</td>
<td>系统时钟，传输发生在上升沿</td>
</tr>
<tr>
<td>PRESETn</td>
<td>复位源</td>
<td>复位信号，低使能</td>
</tr>
<tr>
<td>PADDR</td>
<td>APB桥</td>
<td>地址信号，最高可达32位</td>
</tr>
<tr>
<td>PPROT</td>
<td>APB桥</td>
<td>保护类型，详见手册</td>
</tr>
<tr>
<td>PSELx</td>
<td>APB桥</td>
<td>片选信号，表示x从机是否被选中</td>
</tr>
<tr>
<td>PENABLE</td>
<td>APB桥</td>
<td>使能信号，标记传输使能</td>
</tr>
<tr>
<td>PWRITE</td>
<td>APB桥</td>
<td>读/写控制信号，高位写，低为读</td>
</tr>
<tr>
<td>PWDATA</td>
<td>APB桥</td>
<td>写数据</td>
</tr>
<tr>
<td>PSTRB</td>
<td>APB桥</td>
<td>写选通信号，指示哪个字节是有效的数据，详见手册。</td>
</tr>
<tr>
<td>PREADY</td>
<td>从机</td>
<td>标记从机是否已将数据发送到总线，高为ready</td>
</tr>
<tr>
<td>PRDATA</td>
<td>从机</td>
<td>读数据</td>
</tr>
<tr>
<td>PSLVERR</td>
<td>从机</td>
<td>故障信号，高为发生故障</td>
</tr>
</tbody>
</table>
<h2 id="写时序">写时序</h2>
<h3 id="无等待模式">无等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce54bee66ef089847.png" alt="Write transfer with no wait states" title="Write transfer with no wait states" width=""> 
</center>
<p>两个阶段：<strong>the Setup phase</strong>（设置阶段？），<strong>the Access phase</strong>（访问阶段？）</p>
<p><strong>the Setup phase</strong>（设置阶段）：在T1，地址<strong>PADDR</strong>，写入数据<strong>PWDATA</strong>，写入信号<strong>PWRITE</strong>和选择信号<strong>PSEL</strong>在<strong>PCLK</strong>的上升沿进行寄存，这标志着写操作的开始。</p>
<p><strong>the Access phase</strong>（访问阶段）：在T2，使能信号<strong>PENABLE</strong>和就绪信号<strong>PREADY</strong>在PCLK的上升沿被寄存。</p>
<p><strong>PENABLE</strong>变高表示访问阶段的开始；<strong>PREADY</strong>变高表示从机可以在PCLK的下一个上升沿完成传输。</p>
<p>地址<strong>PADDR</strong>，写入数据<strong>PWDATA</strong>和控制信号都要在传输在T3（<strong>the Access phase</strong>结束）之前保持有效。</p>
<p>使能信号<strong>PENABLE</strong>在传输结束时被置为低电平。选择信号<strong>PSEL</strong>也被置为低电平，除非其后紧跟着对同一外设的另一次写操作。</p>
<h3 id="等待模式">等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce5527ea63b932405.png" alt="Write transfer with wait states" title="Write transfer with wait states" width=""> 
</center>
<p>等待模式引入从机状态信号<strong>PREADY</strong>。在访问阶段，当<strong>PENABLE</strong>为高电平时，从机通过拉低<strong>PREADY</strong>来延时写操作。<strong>PREADY</strong>为低电平期间，以下信号保持不变：</p>
<ul>
<li>address, <strong>PADDR</strong></li>
<li>write signal, <strong>PWRITE</strong></li>
<li>select signal, <strong>PSEL</strong></li>
<li>enable signal, <strong>PENABLE</strong></li>
<li>write data, <strong>PWDATA</strong></li>
<li>write strobes, <strong>PSTRB</strong></li>
<li>protection type, <strong>PPROT</strong>.</li>
</ul>
<p>当<strong>PENABLE</strong>为低电平时，<strong>PREADY</strong>可以设置为任何值以确保具有固定双周期访问权限的外设可以将<strong>PREADY</strong>置为高电平。</p>
<p><strong>注意</strong>：推荐直到下一次访问开始，地址和写操作相关信号一直保持不变。这样可以降低功耗。</p>
<h2 id="读时序">读时序</h2>
<h3 id="无等待模式-2">无等待模式</h3>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce557c70f34888108.png" alt=" Read transfer with no wait states" title=" Read transfer with no wait states" width=""> 
</center>
<p>对照无等待写时序理解，从器件必须在读传输结束前提供数据。</p>
<h3 id="等待模式-2">等待模式</h3>
<p>如果在访问阶段<strong>PREADY</strong>被从机置为低电平，则传输会延时。<strong>PREADY</strong>为低电平期间，以下信号保持不变：</p>
<ul>
<li>address, <strong>PADDR</strong></li>
<li>write signal, <strong>PWRITE</strong></li>
<li>select signal, <strong>PSEL</strong></li>
<li>enable signal, <strong>PENABLE</strong></li>
<li>protection type, <strong>PPROT</strong>.</li>
</ul>
<p>下图显示延时两个时钟周期：</p>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce559ddb398d66056.png" alt="Read transfer with wait states" title="Read transfer with wait states" width=""> 
</center>
<h2 id="系统状态转移">系统状态转移</h2>
<center>
 <img src="https://i.loli.net/2019/05/22/5ce55cbd1326789441.png" alt="State diagram" title="State diagram" width=""> 
</center>
<ul>
<li>
<p>IDLE：初始状态，也是等待传输状态。当片选信号PSELx拉高时总线请求通信，进入SETUP状态</p>
</li>
<li>
<p>SETUP：设置阶段，主从机在该状态设置相应的信号，准备好所有数据。只在该状态停留一个周期，总是在时钟的下一个上升沿到来时进入ACCESS阶段。</p>
</li>
<li>
<p>ACCESS：访问阶段，拉高<strong>PENABLE</strong>信号。在从SETUP到ACCESS状态的转换期间，地址，写入，选择和写入数据信号必须保持稳定。</p>
<p>退出ACCESS阶段由从机状态信号<strong>PREADY</strong>控制：</p>
<ul>
<li>当<strong>PREADY</strong>信号拉高，传输完成，根据是否有下一次传输（<strong>PSELx</strong>是否为高），进入IDLE状还是SETUP状态。</li>
<li>当<strong>PREADY</strong>信号为低，数据未准备好，在ACCESS状态等待<strong>PREADY</strong>信号拉高。</li>
</ul>
</li>
</ul>
<h2 id="其它功能日后补充">其它功能（日后补充）</h2>
<h3 id="写选通">写选通</h3>
<h3 id="传输错误响应">传输错误响应</h3>
<h3 id="保护单元支持">保护单元支持</h3>
<p>参考文档：<a href="https://static.docs.arm.com/ihi0024/c/IHI0024C_amba_apb_protocol_spec.pdf">AMBA APB Protocol Specification v2.0</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-50-52题]]></title>
        <id>https://halftop.github.io/post/verilog99-50to52</id>
        <link href="https://halftop.github.io/post/verilog99-50to52">
        </link>
        <updated>2019-05-20T02:02:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的50-52题是关于亚稳态和复位亚稳态消除问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的50-52题是关于亚稳态和复位亚稳态消除问题。</p>
<!-- more -->
<h3 id="50解释一下亚稳态">50.解释一下亚稳态。</h3>
<p>触发器的建立时间和保持时间在时钟上升沿左右定义了一个时间窗口，如果触发器数据输入端口上的数据在这个时间窗口内发生变化（或者数据更新），那么就会产生时序违规。如果数据在上述窗口中被采集，触发器中的晶体管不能可靠地设置为逻辑0或者逻辑1对应的电平上，导致触发器的输出无法在某个规定时间段内达到一个可以确定的状态，介于0和1之间。亚稳态是可以传播的。</p>
<h3 id="51-用verilog实现异步复位同步释放电路">51. 用verilog实现异步复位同步释放电路。</h3>
<p>关于异步复位，同步释放的更多内容：<a href="https://www.cnblogs.com/linjie-swust/archive/2012/01/07/YWT.html">FPGA中亚稳态——让你无处可逃</a></p>
<center>
 <img src="https://i.loli.net/2019/05/20/5ce2156dd372699513.jpg" alt="异步复位，同步释放" title="异步复位，同步释放" width="600"> 
</center>
<pre><code class="language-verilog">module reset_gen (
    input					clk			, 
    input					rst_async_n	,
    output					rst_sync_n	
);
reg rst_s1, rst_s2;

always @ (posedge clk or negedge rst_async_n)
    if (!rst_async_n)
         begin 
            rst_s1 &lt;= 1'b0;
            rst_s2 &lt;= 1'b0;
        end
    else 
        begin
            rst_s1 &lt;= 1'b1;
            rst_s2 &lt;= rst_s1;
        end

assign rst_sync_n = rst_s2; //rst_sync_n才是我们真正对系统输出的复位信号

endmodule 
</code></pre>
<h3 id="52-用verilog实现异步复位同步释放电路支持测试模式的复位信号切换">52. 用verilog实现异步复位同步释放电路，支持测试模式的复位信号切换。</h3>
<pre><code class="language-verilog">module reset_gen (
    input					clk			, 
    input					rst_async_n	,
    input					test_shift  ,
    output					rst_sync_n	
);
reg rst_s1;
reg rst_s2;
wire tmrst;

assign  tmrst = rst_async_n | test_shift;

always @ (posedge clk or negedge tmrst)
    if (!tmrst)
         begin 
            rst_s1 &lt;= 1'b0;
            rst_s2 &lt;= 1'b0;
        end
    else 
        begin
            rst_s1 &lt;= 1'b1;
            rst_s2 &lt;= rst_s1;
        end

assign rst_sync_n = rst_s2;

endmodule 
</code></pre>
<p>这个测试模式的用意还未领悟，本题的<a href="https://www.eetimes.com/document.asp?doc_id=1145510">参考链接</a>。以门控时钟和复位信号，讲解了测试模式的一些知识。文章中有一处错误，讲解复位信号的测试模式切换的时候，少写了取反符号（粗心所致）。如下图：</p>
<center>
 <img src="https://i.loli.net/2019/05/20/5ce265a70875a57159.png" alt="错误示例" title="错误示例" width=""> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog没有葵花宝典——day13（存储器）]]></title>
        <id>https://halftop.github.io/post/verilog-day13</id>
        <link href="https://halftop.github.io/post/verilog-day13">
        </link>
        <updated>2019-05-16T08:24:29.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>存储名词解释</li>
<li>用verilog实现一个深度为16，位宽8bit的单端口SRAM。搭建一个仿真环境，完成初始化，读取，写入的操作。</li>
<li>接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</li>
<li>使用单端口SRAM构造一个双端口同步FIFO。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol>
<li>存储名词解释</li>
<li>用verilog实现一个深度为16，位宽8bit的单端口SRAM。搭建一个仿真环境，完成初始化，读取，写入的操作。</li>
<li>接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</li>
<li>使用单端口SRAM构造一个双端口同步FIFO。</li>
</ol>
</blockquote>
<!-- more --> 
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#1-%E5%AD%98%E5%82%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">1. 存储名词解释</a></li>
<li><a href="#2-%E5%8D%95%E7%AB%AF%E5%8F%A3sram">2. 单端口SRAM</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">Verilog描述</a></li>
<li><a href="#testbench">testbench</a></li>
</ul>
</li>
<li><a href="#3-%E6%8E%A5%E7%AC%AC2%E9%A2%98%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%92%8C%E5%86%99%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%80%8E%E6%A0%B7%E5%AE%9E%E9%99%85%E4%B8%AD%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">3. 接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8%E5%8D%95%E7%AB%AF%E5%8F%A3sram%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%8F%8C%E7%AB%AF%E5%8F%A3%E5%90%8C%E6%AD%A5fifo">4. 使用单端口SRAM构造一个双端口同步FIFO。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="1-存储名词解释">1. 存储名词解释</h3>
<p>见<a href="https://halftop.github.io/post/verilog99_31to37/#31%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">Verilog99题的第31题</a></p>
<h3 id="2-单端口sram">2. 单端口SRAM</h3>
<h4 id="verilog描述">Verilog描述</h4>
<pre><code class="language-verilog">module spram
#(
    parameter WD = 8,       //数据位宽
    parameter AD = 4       //地址位宽
)
(
    input               clk     ,
    input               cs_n    ,
    input               w_r_n   ,
    input       [AD-1:0]  addr    ,
    input       [WD-1:0]  din     ,
    output  reg [WD-1:0]  dout    
    );
localparam	DP=1&lt;&lt;AD；
reg [WD-1:0]  buffer  [DP-1:0];

always @(posedge clk) begin
    casex ({cs_n,w_r_n})
        2'b1x: dout &lt;= 'hx;
        2'b01: buffer[addr] &lt;= din;
        2'b00: dout &lt;= buffer[addr];
        default: ;
    endcase
end

endmodule
</code></pre>
<h4 id="testbench">testbench</h4>
<pre><code class="language-verilog">`timescale 1ns / 1ps

// memory inst hierachy name
`define MEM_INST      tb34.spram16_8.buffer
// memory initilazation file (hex format)
`define MEM_INIT_FILE &quot;E:/verilog/test/test.srcs/sources_1/new/sp_mem_init.hex&quot;

module tb34(    );
reg             clk     ;
reg             cs_n    ;
reg             w_r_n   ;
reg     [4:1]   addr    ;
reg     [8:1]   din     ;
wire    [8:1]   dout    ;

initial begin
    clk = 1;
    forever #10 clk = ~clk;
  end

// memory initilization
integer fp_dmem;

initial begin
    fp_dmem = $fopen(`MEM_INIT_FILE, &quot;r&quot;);  //open for read
    if(fp_dmem)
        #5 $readmemh(`MEM_INIT_FILE, `MEM_INST);
    else begin
        $display(&quot;%s open failed.&quot;,`MEM_INIT_FILE);
        $finish;
    end
end

integer i;
initial begin
    cs_n = 1'b1;
    w_r_n = 1'b0;
    addr = 4'd0;
    din = 8'h00;
    #100
    @(negedge clk)//read
        cs_n = 1'b0;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk)
            addr = i;
    end
    @(negedge clk)//write
        w_r_n = 1'b1;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk) begin
            addr = i;
            din = i + 'ha0;
        end
    end
    @(negedge clk)//read
        w_r_n = 1'b0;
    for (i = 0; i&lt;16; i=i+1) begin
        @(negedge clk)
            addr = i;
    end
    @(negedge clk)
        cs_n = 1'b1;
    // #100 $finish;
    #100 $stop;
end

/* initial begin
    $dumpfile(&quot;spram_tb.vcd&quot;);
    $dumpvars();
end */
spram #(
    .WD ( 8),
    .AD ( 4)
)
spram16_8
(
    .clk     ( clk   ),
    .cs_n    ( cs_n  ),
    .w_r_n   ( w_r_n ),
    .addr    ( addr  ),
    .din     ( din   ),
    .dout    ( dout  )
    );
endmodule
</code></pre>
<h3 id="3-接第2题如果同时对一个地址进行读和写操作会怎样实际中应该如何处理">3. 接第2题，如果同时对一个地址进行读和写操作，会怎样?实际中应该如何处理?</h3>
<p>目前的水平觉得不会，但是大神们讨论了很多，不敢说话。</p>
<h3 id="4-使用单端口sram构造一个双端口同步fifo">4. 使用单端口SRAM构造一个双端口同步FIFO。</h3>
<p>放出大神的思路<a href="https://mp.weixin.qq.com/s/Sl9-BeUJ6bUNzjsUQvYqUQ">使用单端口SRAM构造一个双端口同步FIFO</a></p>
<p>只想说厉害了！说得比较通俗易懂，实现起来没那么简单~</p>
<p>估计今天是实现不了了，留坑！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题-47-49题（时钟相关）]]></title>
        <id>https://halftop.github.io/post/verilog99-47to49</id>
        <link href="https://halftop.github.io/post/verilog99-47to49">
        </link>
        <updated>2019-05-14T08:32:38.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的47-49题是关于时钟。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><a href="https://mp.weixin.qq.com/s/prdZKHbKTFMH80eRnr7mLQ">不忘出芯veriloig99题</a>的47-49题是关于时钟。</p>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#47-%E7%94%BB%E5%87%BAclock-gating-cell%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE">47. 画出clock gating cell的原理图。</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8Elatch%E5%92%8C%E4%B8%8E%E9%97%A8">基于latch和与门</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Elatch%E5%92%8C%E6%88%96%E9%97%A8">基于latch和或门</a></li>
<li><a href="#48-%E7%94%A8verilog%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E7%94%B5%E8%B7%AF-%E5%A4%96%E9%83%A8%E7%AE%A1%E8%84%9A%E8%BE%93%E5%85%A5selclktestclk-sel%E4%B8%BA1%E8%BE%93%E5%87%BAclksel%E4%B8%BA0%E8%BE%93%E5%87%BAtestclk">48. 用verilog实现静态时钟切换电路。外部管脚输入sel，clk，testclk。sel为1输出clk，sel为0输出testclk。</a></li>
<li><a href="#49-%E7%94%A8verilog%E5%AE%9E%E7%8E%B0glitch-free%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E7%94%B5%E8%B7%AF-%E8%BE%93%E5%85%A5selclkaclkbsel%E4%B8%BA1%E8%BE%93%E5%87%BAclkasel%E4%B8%BA0%E8%BE%93%E5%87%BAclkb">49. 用verilog实现glitch free时钟切换电路。输入sel，clka，clkb，sel为1输出clka，sel为0输出clkb。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="47-画出clock-gating-cell的原理图">47. 画出clock gating cell的原理图。</h3>
<h4 id="基于latch和与门">基于latch和与门</h4>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda80576019768349.png" alt="ICG_AND" title="ICG_AND" width=""> 
</center>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda83e3d3c2768584.png" alt="AND_ICG_tim" title="AND_ICG_tim" width=""> 
</center>
<h4 id="基于latch和或门">基于latch和或门</h4>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda80ab9f0fa61819.png" alt="ICG_OR" title="ICG_OR" width=""> 
</center>
<center>
 <img src="https://i.loli.net/2019/05/14/5cda84254038421193.png" alt="OR_ICG_timOR_ICG_tim" title="OR_ICG_tim" width=""> 
</center>
<h4 id="48-用verilog实现静态时钟切换电路-外部管脚输入selclktestclk-sel为1输出clksel为0输出testclk">48. 用verilog实现静态时钟切换电路。外部管脚输入sel，clk，testclk。sel为1输出clk，sel为0输出testclk。</h4>
<pre><code class="language-verilog">module clk_switch(
    input                   clk0        ,
    input                   clk1        ,
    input                   rst_n       ,
    input                   select      ,
    output                  outclk      
    );

    assign outclk = select ? clk1 : clk0;
</code></pre>
<h4 id="49-用verilog实现glitch-free时钟切换电路-输入selclkaclkbsel为1输出clkasel为0输出clkb">49. 用verilog实现glitch free时钟切换电路。输入sel，clka，clkb，sel为1输出clka，sel为0输出clkb。</h4>
<pre><code class="language-verilog">module clk_switch(
    input                   clk0        ,
    input                   clk1        ,
    input                   rst_n       ,
    input                   select      ,
    output                  outclk      
    );

reg     out_r1;
reg     out1;
reg     out_r0;
reg     out0;
 
 always @(posedge clk1 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out_r1 &lt;= 0;
     end
     else begin
         out_r1 &lt;= ~out0 &amp; select;
     end
 end
 
 always @(negedge clk1 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out1 &lt;= 0;
     end
     else begin
         out1 &lt;= out_r1;
     end
 end
 
 always @(posedge clk0 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out_r0 &lt;= 0;
     end
     else begin
         out_r0 &lt;= ~select &amp; ~out1;
     end
 end
 
 always @(negedge clk0 or negedge rst_n)begin
     if(rst_n == 1'b0)begin
         out0 &lt;= 0;
     end
     else begin
         out0 &lt;= out_r0;
     end
 end
 
 assign outclk = (out1 &amp; clk1) | (out0 &amp; clk0);
endmodule
</code></pre>
<p>具体请点击<a href="https://mp.weixin.qq.com/s/w3Wu7HkSr5v94kHrLvRIcw">中文版</a>或<a href="https://www.eetimes.com/document.asp?doc_id=1202359">英文版</a>。</p>
<p><a href="https://www.cnblogs.com/-9-8/p/5409862.html">另附1篇</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题——45.46题（奇、偶分频）]]></title>
        <id>https://halftop.github.io/post/verilog99-45to46</id>
        <link href="https://halftop.github.io/post/verilog99-45to46">
        </link>
        <updated>2019-05-10T07:58:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="45">
<li>用verilog实现二分频。</li>
<li>用verilog实现三分频电路，要求输出50%占空比。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="45">
<li>用verilog实现二分频。</li>
<li>用verilog实现三分频电路，要求输出50%占空比。</li>
</ol>
</blockquote>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF%E5%8F%8A%E6%96%B9%E6%B3%95">思路及方法</a></li>
<li><a href="#45">45</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">verilog描述</a></li>
</ul>
</li>
<li><a href="#46">46</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-2">verilog描述</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">仿真结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="思路及方法">思路及方法</h3>
<p>偶数分频十分简单,只需用高速时钟做一个同步计数器,然后在相应的位抽头即可。奇数分频电路相对复杂些。引用一篇比较详细的blog：<a href="https://mp.weixin.qq.com/s/Xd6vn51L1hD0mRClQbVfaQ">verilog实现简单分频器</a></p>
<h3 id="45">45</h3>
<h4 id="verilog描述">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: 二分频
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-10 10:37:19
// LastEditTime: 2019-05-10 11:04:06
// ********************************************************************
// Module Function:二分频
`timescale 1ns / 1ps

module div_2(
    input					clk			,
    input					rst_n		,
    output  reg             clk_out     
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out &lt;= 1'b0;
    end else begin
        clk_out &lt;= ~clk_out;
    end
end

endmodule
</code></pre>
<h3 id="46">46</h3>
<h4 id="verilog描述-2">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: 实现任意奇数分频
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-10 11:04:51
// LastEditTime: 2019-05-10 22:18:17
// ********************************************************************
// Module Function:实现任意奇数分频
`timescale 1ns / 1ps

module div_odd
#(
    parameter N	= 3
    
)
(
    input					clk			,
    input					rst_n		,
    output                  clk_out     
);

localparam  WD = clogb2(N);

reg                 clk_out_p   ;
reg                 clk_out_n   ;
reg     [WD-1:0]    count       ;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        count &lt;= 'd0;
    end else if (count==N-1) begin
        count &lt;= 'd0;
    end else begin
        count &lt;= count + 1'b1;
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out_p &lt;= 1'b1;
    end else if (count&gt;N/2) begin
        clk_out_p &lt;= 1'b0;
    end else begin
        clk_out_p &lt;= 1'b1;
    end
end

always @(negedge clk or negedge rst_n) begin
    if (!rst_n) begin
        clk_out_n &lt;= 1'b0;
    end else begin
        clk_out_n &lt;= clk_out_p;
    end
end

assign clk_out = clk_out_p&amp;clk_out_n;

function integer clogb2 (input integer depth);
    begin
        for(clogb2=0; depth&gt;0; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
    end
endfunction

endmodule
</code></pre>
<h4 id="仿真结果">仿真结果</h4>
<p>三分频：</p>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd589db5ed2a.png" alt="三分频仿真结果" title="三分频仿真结果" width="800"> 
</center>
<p>七分频：</p>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd58b4047f97.png" alt="七分频仿真结果" title="七分频仿真结果" width="800"> 
</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog99题——43、44题（两道算法题）]]></title>
        <id>https://halftop.github.io/post/verilog99_43to44</id>
        <link href="https://halftop.github.io/post/verilog99_43to44">
        </link>
        <updated>2019-05-10T07:56:46.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="43">
<li>用verilog实现 <code>y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)</code> 输入x是8bit无符号数。</li>
<li>用verilog实现 <code>y(n) = 0.75*x(n) + 0.25*y(n-1)</code> x, y是8bit无符号数。</li>
</ol>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<blockquote>
<ol start="43">
<li>用verilog实现 <code>y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)</code> 输入x是8bit无符号数。</li>
<li>用verilog实现 <code>y(n) = 0.75*x(n) + 0.25*y(n-1)</code> x, y是8bit无符号数。</li>
</ol>
</blockquote>
<!-- more -->
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE">题目</a>
<ul>
<li><a href="#43">43</a>
<ul>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0">verilog描述</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E5%9B%BE">仿真图</a></li>
<li><a href="#verilog%E6%8F%8F%E8%BF%B0-2">verilog描述</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E5%87%BA%E7%9A%84%E7%94%B5%E8%B7%AF%E5%9B%BE">综合出的电路图</a></li>
<li><a href="#%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C">仿真结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="43">43</h3>
<p>用移位寄存器实现时延，这里参数化了位宽和个数，注意组合逻辑中阻塞赋值的用法。</p>
<h4 id="verilog描述">verilog描述</h4>
<pre><code class="language-verilog">// --------------------------------------------------------------------
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COPYRIGHT NOTICE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// --------------------------------------------------------------------
// Author: halftop
// Github: https://github.com/halftop
// Email: yu.zh@live.com
// Description: y(n) = x(n) + x(n-1) + x(n-2) + x(n-3) + x(n-4)+ x(n-5)+ x(n-6)+ x(n-7)+···
// Dependencies: 
// LastEditors: halftop
// Since: 2019-05-09 10:30:00
// LastEditTime: 2019-05-09 15:58:20
// ********************************************************************
// Module Function:
`timescale 1ns / 1ps

module test43
#(
    parameter WIDTH	= 8 ,
                DEPTH = 8   ,
                YWD = WIDTH+clogb2(DEPTH)
)
(
    input					clk			,
    input					rst_n		,
    input       [WIDTH-1:0] i_data      ,
    output  reg [YWD-1:0]   o_y 
);

reg     [WIDTH-1:0]     data_r      [DEPTH-1:0];

integer i;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for ( i=0 ;i&lt;DEPTH ;i=i+1 ) begin
            data_r[i] &lt;= 'd0;
        end
    end else begin
        data_r[0] &lt;= i_data;
        for ( i=1 ;i&lt;DEPTH ;i=i+1 ) begin
            data_r[i] &lt;= data_r[i-1];
        end
    end
end

reg     [YWD-1:0] sum_comb;
always @(*) begin
    sum_comb = 'd0;
    for ( i=0 ;i&lt;DEPTH ; i=i+1) begin
        sum_comb = sum_comb + data_r[i];
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        o_y &lt;= 'd0;
    end else begin
        o_y &lt;= sum_comb;
    end
end

function integer clogb2 (input integer depth);
    begin
        for(clogb2=0; depth&gt;1; clogb2=clogb2+1)
        depth = depth &gt;&gt; 1;
    end
endfunction
endmodule
</code></pre>
<h4 id="仿真图">仿真图</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd537bba7194.png" alt="仿真图" title="仿真图" width=""> 
</center>
### 44
<p>注意其中非阻塞式赋值起到的关键作用。</p>
<h4 id="verilog描述-2">verilog描述</h4>
<pre><code class="language-verilog">module test44(
    input					clk			,
    input					rst_n		,
    input       [7:0]       i_data      ,
    output      [7:0]       o_y         
);
// y(n) = 0.75x(n) + 0.25y(n-1) 
//0.75*4 = 3，0.25*4 = 1

reg [9:0] dout;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        dout &lt;= 'd0;
    end else begin
        dout &lt;= 3*i_data + dout;
    end
end

assign o_y = dout&gt;&gt;2;

endmodule
</code></pre>
<h4 id="综合出的电路图">综合出的电路图</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd5832ecfddd.png" alt="44综合出的电路图" title="44综合出的电路图" width="800"> 
</center>
<h4 id="仿真结果">仿真结果</h4>
<center>
 <img src="https://i.loli.net/2019/05/10/5cd583f21bc1f.png" alt="44仿真结果" title="44仿真结果" width="800"> 
</center>]]></content>
    </entry>
</feed>